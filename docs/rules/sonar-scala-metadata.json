{
  "repositories": {
    "sonar-scala-scalastyle": {
      "key": "sonar-scala-scalastyle",
      "name": "Scalastyle",
      "rules": [
        {
          "description": "*Checks that block imports are not used.*\n\nBlock imports, e.g. `import a.{b, c}` can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports are used in order to minimize merge errors in import declarations.",
          "key": "org.scalastyle.scalariform.BlockImportChecker",
          "name": "Avoid block imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.BlockImportChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that curlies imports are not used.*\n\nCurlies imports, e.g. `import a.{b, c}`, can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports, no renaming and no hiding imports are used in order to minimize merge errors in import declarations.",
          "key": "org.scalastyle.scalariform.CurliesImportChecker",
          "name": "Avoid curlies imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.CurliesImportChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Avoid wildcard imports.*\n\nImporting all classes from a package or static members from a class leads to tight coupling between packages or classes and might lead to problems when a new version of a library introduces name clashes.",
          "key": "org.scalastyle.scalariform.UnderscoreImportChecker",
          "name": "Avoid wildcard imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.UnderscoreImportChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that class names match a regular expression.*\n\nThe Scala style guide recommends that class names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ClassNamesChecker-template",
          "name": "Class name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The class names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that class names match a regular expression.*\n\nThe Scala style guide recommends that class names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ClassNamesChecker",
          "name": "Class name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The class names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that type parameter to a class matches a regular expression.*\n\nScala generic type names are generally single upper case letters. This check checks for classes and traits. Note that this check only checks the innermost type parameter, to allow for `List[T]`.",
          "key": "org.scalastyle.scalariform.ClassTypeParameterChecker-template",
          "name": "Class type parameter name",
          "params": [
            {
              "default": "^[A-Z_]$",
              "description": "Regular expression: Standard Scala regular expression syntax.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassTypeParameterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that type parameter to a class matches a regular expression.*\n\nScala generic type names are generally single upper case letters. This check checks for classes and traits. Note that this check only checks the innermost type parameter, to allow for `List[T]`.",
          "key": "org.scalastyle.scalariform.ClassTypeParameterChecker",
          "name": "Class type parameter name",
          "params": [
            {
              "default": "^[A-Z_]$",
              "description": "Regular expression: Standard Scala regular expression syntax.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassTypeParameterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that classes and objects do not define the clone() method.*\n\nThe clone method is difficult to get right. You can use the copy constructor of case classes rather than implementing clone. For more information on `clone()`, see Effective Java by Joshua Bloch pages.",
          "key": "org.scalastyle.scalariform.NoCloneChecker",
          "name": "Clone method",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoCloneChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that classes and objects do not define equals without overriding equals(java.lang.Object).*\n\nMistakenly defining a covariant `equals()` method without overriding method `equals(java.lang.Object)` can produce unexpected runtime behaviour.",
          "key": "org.scalastyle.scalariform.CovariantEqualsChecker",
          "name": "Covariant equals",
          "params": [
            {
              "default": "org.scalastyle.scalariform.CovariantEqualsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that the cyclomatic complexity of a method does exceed a value.*\n\nIf the code is too complex, then this can make code hard to read.",
          "key": "org.scalastyle.scalariform.CyclomaticComplexityChecker-template",
          "name": "Cyclomatic complexity",
          "params": [
            {
              "default": "10",
              "description": "Maximum: Maximum cyclomatic complexity to allow for a method.",
              "name": "maximum",
              "typ": "Integer"
            },
            {
              "default": "true",
              "description": "Count Cases: If true, each case increases method complexity, else only match keyword is considered.",
              "name": "countCases",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that the cyclomatic complexity of a method does exceed a value.*\n\nIf the code is too complex, then this can make code hard to read.",
          "key": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
          "name": "Cyclomatic complexity",
          "params": [
            {
              "default": "10",
              "description": "Maximum: Maximum cyclomatic complexity to allow for a method.",
              "name": "maximum",
              "typ": "Integer"
            },
            {
              "default": "true",
              "description": "Count Cases: If true, each case increases method complexity, else only match keyword is considered.",
              "name": "countCases",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*The interpolation for this string literal is not necessary.*\n\nEmpty interpolated strings are harder to read and not necessary.",
          "key": "org.scalastyle.scalariform.EmptyInterpolatedStringChecker",
          "name": "Empty interpolated string",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EmptyInterpolatedStringChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that if a class implements either equals or hashCode, it should implement the other.*\n\nDefining either equals or hashCode in a class without defining the is a known source of bugs. Usually, when you define one, you should also define the other.",
          "key": "org.scalastyle.scalariform.EqualsHashCodeChecker",
          "name": "Equals hashCode",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EqualsHashCodeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that field names match a regular expression.*\n\nA consistent naming convention for field names can make code easier to read and understand.",
          "key": "org.scalastyle.scalariform.FieldNamesChecker-template",
          "name": "Field name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The field names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^[A-Z][A-Za-z0-9]*$",
              "description": "Regular expression for constants: The object field (constant) names must match this regular expression.",
              "name": "objectFieldRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.FieldNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that field names match a regular expression.*\n\nA consistent naming convention for field names can make code easier to read and understand.",
          "key": "org.scalastyle.scalariform.FieldNamesChecker",
          "name": "Field name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The field names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^[A-Z][A-Za-z0-9]*$",
              "description": "Regular expression for constants: The object field (constant) names must match this regular expression.",
              "name": "objectFieldRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.FieldNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check the number of lines in a file.*\n\nFiles which are too long can be hard to read and understand.",
          "key": "org.scalastyle.file.FileLengthChecker-template",
          "name": "File length",
          "params": [
            {
              "default": "1500",
              "description": "Maximum file length: Maximum number of lines in a file.",
              "name": "maxFileLength",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.file.FileLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check the number of lines in a file.*\n\nFiles which are too long can be hard to read and understand.",
          "key": "org.scalastyle.file.FileLengthChecker",
          "name": "File length",
          "params": [
            {
              "default": "1500",
              "description": "Maximum file length: Maximum number of lines in a file.",
              "name": "maxFileLength",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.file.FileLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check the number of characters in a line.*\n\nLines that are too long can be hard to read and horizontal scrolling is annoying.",
          "key": "org.scalastyle.file.FileLineLengthChecker-template",
          "name": "File line length",
          "params": [
            {
              "default": "160",
              "description": "Maximum line length: Maximum number of characters in a line.",
              "name": "maxLineLength",
              "typ": "Integer"
            },
            {
              "default": "4",
              "description": "Tab size: Number of characters that a tab represents.",
              "name": "tabSize",
              "typ": "Integer"
            },
            {
              "default": "false",
              "description": "Ignore import statements: Ignore import statements.",
              "name": "ignoreImports",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.FileLineLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check the number of characters in a line.*\n\nLines that are too long can be hard to read and horizontal scrolling is annoying.",
          "key": "org.scalastyle.file.FileLineLengthChecker",
          "name": "File line length",
          "params": [
            {
              "default": "160",
              "description": "Maximum line length: Maximum number of characters in a line.",
              "name": "maxLineLength",
              "typ": "Integer"
            },
            {
              "default": "4",
              "description": "Tab size: Number of characters that a tab represents.",
              "name": "tabSize",
              "typ": "Integer"
            },
            {
              "default": "false",
              "description": "Ignore import statements: Ignore import statements.",
              "name": "ignoreImports",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.FileLineLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that classes and objects do not define the finalize() method.*\n\n`finalize()` is called when the object is garbage collected, and garbage collection is not guaranteed to happen. It is therefore unwise to rely on code in `finalize()` method.",
          "key": "org.scalastyle.scalariform.NoFinalizeChecker",
          "name": "Finalize method",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoFinalizeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that imports are grouped together, not throughout the file.*\n\nIf imports are spread throughout the file, knowing what is in scope at any one place can be difficult to work out.",
          "key": "org.scalastyle.scalariform.ImportGroupingChecker",
          "name": "Group imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ImportGroupingChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that if statements have braces.*\n\nSome people find if clauses with braces easier to read.\n\nThe `singleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nThe `doubleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nNote: If you intend to enable only if expressions in the format below, disable the IfBraceChecker altogether.\n\n```scala\nif (bool_expression) expression1 else expression2\n```",
          "key": "org.scalastyle.scalariform.IfBraceChecker-template",
          "name": "If block braces",
          "params": [
            {
              "default": "true",
              "description": "Single Line Allowed: If without braces allowed if everything is on one line.",
              "name": "singleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "false",
              "description": "Double Line Allowed: If without braces allowed if everything is on one line or two lines.",
              "name": "doubleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.IfBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that if statements have braces.*\n\nSome people find if clauses with braces easier to read.\n\nThe `singleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nThe `doubleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nNote: If you intend to enable only if expressions in the format below, disable the IfBraceChecker altogether.\n\n```scala\nif (bool_expression) expression1 else expression2\n```",
          "key": "org.scalastyle.scalariform.IfBraceChecker",
          "name": "If block braces",
          "params": [
            {
              "default": "true",
              "description": "Single Line Allowed: If without braces allowed if everything is on one line.",
              "name": "singleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "false",
              "description": "Double Line Allowed: If without braces allowed if everything is on one line or two lines.",
              "name": "doubleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.IfBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that a class does not import certain classes.*\n\nUse of some classes can be discouraged for a project. For instance, use of `sun._` is generally discouraged because they are internal to the JDK and can be changed.",
          "key": "org.scalastyle.scalariform.IllegalImportsChecker-template",
          "name": "Illegal imports",
          "params": [
            {
              "default": "sun._,java.awt._",
              "description": "Illegal Imports: The comma separated list of illegal imports, wildcards allowed.",
              "name": "illegalImports",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.IllegalImportsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that a class does not import certain classes.*\n\nUse of some classes can be discouraged for a project. For instance, use of `sun._` is generally discouraged because they are internal to the JDK and can be changed.",
          "key": "org.scalastyle.scalariform.IllegalImportsChecker",
          "name": "Illegal imports",
          "params": [
            {
              "default": "sun._,java.awt._",
              "description": "Illegal Imports: The comma separated list of illegal imports, wildcards allowed.",
              "name": "illegalImports",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.IllegalImportsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that imports are grouped and ordered according to the style configuration.*\n\nConsistent import ordering improves code readability and reduces unrelated changes in patches.",
          "key": "org.scalastyle.scalariform.ImportOrderChecker",
          "name": "Import Order",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ImportOrderChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that there are no tabs in a file.*\n\nSome say that tabs are evil.",
          "key": "org.scalastyle.file.FileTabChecker",
          "name": "Line contains Tab",
          "params": [
            {
              "default": "org.scalastyle.file.FileTabChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that argument literals are named.*\n\nNameless literals make code harder to understand (consider `updateEntity(1, true)` and `updateEntity(id = 1, enabled = true)`).",
          "key": "org.scalastyle.scalariform.NamedArgumentChecker-template",
          "name": "Literal passed as argument without name",
          "params": [
            {
              "default": "false",
              "description": "Check string literals: If true, also checks that string literal arguments are named.",
              "name": "checkString",
              "typ": "Boolean"
            },
            {
              "default": "^set.+$",
              "description": "Ignore methods by pattern: Pattern to ignore method calls by name.",
              "name": "ignoreMethod",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.NamedArgumentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that argument literals are named.*\n\nNameless literals make code harder to understand (consider `updateEntity(1, true)` and `updateEntity(id = 1, enabled = true)`).",
          "key": "org.scalastyle.scalariform.NamedArgumentChecker",
          "name": "Literal passed as argument without name",
          "params": [
            {
              "default": "false",
              "description": "Check string literals: If true, also checks that string literal arguments are named.",
              "name": "checkString",
              "typ": "Boolean"
            },
            {
              "default": "^set.+$",
              "description": "Ignore methods by pattern: Pattern to ignore method calls by name.",
              "name": "ignoreMethod",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.NamedArgumentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that if a long literal is used, then an uppercase L is used.*\n\nA lowercase L (l) can look similar to a number 1 with some fonts.",
          "key": "org.scalastyle.scalariform.UppercaseLChecker",
          "name": "Long literal uppercase L",
          "params": [
            {
              "default": "org.scalastyle.scalariform.UppercaseLChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a case statement pattern match is not lower case, as this can cause confusion.*\n\nA lower case pattern match clause with no other tokens is the same as `_`; this is not true for patterns which start with an upper case letter. This can cause confusion, and may not be what was intended:\n\n```scala\nval foo = \"foo\"\nval Bar = \"bar\"\n\"bar\" match { case Bar => \"we got bar\" } // result = \"we got bar\"\n\"bar\" match { case foo => \"we got foo\" } // result = \"we got foo\"\n\"bar\" match { case `foo` => \"we got foo\" } // result = MatchError\n```\n\nThis checker raises a warning with the second match. To fix it, use an identifier which starts with an upper case letter (best), use `case _` or, if you wish to refer to the value, add a type `: Any`, e.g.:\n\n```scala\nval lc = \"lc\"\n\"something\" match { case lc: Any => \"lc\" } // result = \"lc\"\n\"something\" match { case _ => \"lc\" } // result = \"lc\"\n```",
          "key": "org.scalastyle.scalariform.LowercasePatternMatchChecker",
          "name": "Lowercase pattern match",
          "params": [
            {
              "default": "org.scalastyle.scalariform.LowercasePatternMatchChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of magic numbers.*\n\nReplacing a magic number with a named constant can make code easier to read and understand, and can avoid some subtle bugs.\n\nA simple assignment to a val is not considered to be a magic number, for example: `val foo = 4` is not a magic number, but `var foo = 4` is considered to be a magic number.",
          "key": "org.scalastyle.scalariform.MagicNumberChecker-template",
          "name": "Magic Number",
          "params": [
            {
              "default": "-1,0,1,2",
              "description": "Ignore: The comma separated list of numbers to ignore when used as magic numbers.",
              "name": "ignore",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MagicNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks for use of magic numbers.*\n\nReplacing a magic number with a named constant can make code easier to read and understand, and can avoid some subtle bugs.\n\nA simple assignment to a val is not considered to be a magic number, for example: `val foo = 4` is not a magic number, but `var foo = 4` is considered to be a magic number.",
          "key": "org.scalastyle.scalariform.MagicNumberChecker",
          "name": "Magic Number",
          "params": [
            {
              "default": "-1,0,1,2",
              "description": "Ignore: The comma separated list of numbers to ignore when used as magic numbers.",
              "name": "ignore",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MagicNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check the first lines of each file matches the text.*\n\nA lot of projects require a header with a copyright notice, or they require a license in each file. This does a simple text comparison between the header and the first lines of the file. You can have multiple lines, but make sure you surround the text with a `CDATA` section. You can also specify a regular expression, as long as you set the regex parameter to `true`.",
          "key": "org.scalastyle.file.HeaderMatchesChecker-template",
          "name": "Match Header",
          "params": [
            {
              "default": "",
              "description": "Header: The lines to compare against.",
              "name": "header",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Header Regex: Whether to treat the header string as a regular expression.",
              "name": "regex",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.HeaderMatchesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Maximum number of parameters for a method.*\n\nA method which has more than a certain number of parameters can be hard to understand.",
          "key": "org.scalastyle.scalariform.ParameterNumberChecker-template",
          "name": "Maximum parameters",
          "params": [
            {
              "default": "8",
              "description": "Maximum Number: The maximum number of parameters.",
              "name": "maxParameters",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.ParameterNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Maximum number of parameters for a method.*\n\nA method which has more than a certain number of parameters can be hard to understand.",
          "key": "org.scalastyle.scalariform.ParameterNumberChecker",
          "name": "Maximum parameters",
          "params": [
            {
              "default": "8",
              "description": "Maximum Number: The maximum number of parameters.",
              "name": "maxParameters",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.ParameterNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that method argument names match a regular expression.*\n\nThe Scala style guide recommends that method argument names conform to certain standards.",
          "key": "org.scalastyle.scalariform.MethodArgumentNamesChecker-template",
          "name": "Method argument name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The method argument names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method argument names which match this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that method argument names match a regular expression.*\n\nThe Scala style guide recommends that method argument names conform to certain standards.",
          "key": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
          "name": "Method argument name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The method argument names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method argument names which match this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that methods do not exceed a maximum length.*\n\nLong methods can be hard to read and understand.",
          "key": "org.scalastyle.scalariform.MethodLengthChecker-template",
          "name": "Method length",
          "params": [
            {
              "default": "50",
              "description": "Maximum length: Maximum number of lines allowed for a method.",
              "name": "maxLength",
              "typ": "Integer"
            },
            {
              "default": "false",
              "description": "Ignore comments: If set to true, comment lines in method body won't be counted.",
              "name": "ignoreComments",
              "typ": "Boolean"
            },
            {
              "default": "false",
              "description": "Ignore empty lines: If set to true, empty lines in method body won't be counted.",
              "name": "ignoreEmpty",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.MethodLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that methods do not exceed a maximum length.*\n\nLong methods can be hard to read and understand.",
          "key": "org.scalastyle.scalariform.MethodLengthChecker",
          "name": "Method length",
          "params": [
            {
              "default": "50",
              "description": "Maximum length: Maximum number of lines allowed for a method.",
              "name": "maxLength",
              "typ": "Integer"
            },
            {
              "default": "false",
              "description": "Ignore comments: If set to true, comment lines in method body won't be counted.",
              "name": "ignoreComments",
              "typ": "Boolean"
            },
            {
              "default": "false",
              "description": "Ignore empty lines: If set to true, empty lines in method body won't be counted.",
              "name": "ignoreEmpty",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.MethodLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that method names match a regular expression.*\n\nThe Scala style guide recommends that method names conform to certain standards. If the methods are overriding another method, and the overridden method cannot be changed, then use the `ignoreOverride` parameter.",
          "key": "org.scalastyle.scalariform.MethodNamesChecker-template",
          "name": "Method name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*(_=)?$",
              "description": "Regular expression: The method names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method names which match this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.MethodNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that method names match a regular expression.*\n\nThe Scala style guide recommends that method names conform to certain standards. If the methods are overriding another method, and the overridden method cannot be changed, then use the `ignoreOverride` parameter.",
          "key": "org.scalastyle.scalariform.MethodNamesChecker",
          "name": "Method name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*(_=)?$",
              "description": "Regular expression: The method names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method names which match this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.MethodNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that the ScalaDoc on documentable members is well-formed.*\n\nScaladoc is generally considered a good thing. Within reason.\n\nIgnore tokens is a comma separated string that may include the following: `PatDefOrDcl` (variables), `TmplDef` (classes, traits), `TypeDefOrDcl` (type definitions), `FunDefOrDcl` (functions). Supported indentation styles are \"scaladoc\" (for ScalaDoc-style comments, with two spaces before the asterisk), \"javadoc\" (for JavaDoc-style comments, with a single space before the asterisk) or \"anydoc\" to support any style (any number of spaces before the asterisk). For backwards compatibility, if left empty, \"anydoc\" will be assumed.",
          "key": "org.scalastyle.scalariform.ScalaDocChecker-template",
          "name": "Missing or badly formed ScalaDoc",
          "params": [
            {
              "default": "^$",
              "description": "Regular expression: Class names matching this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Comma Separated String: Include the following to ignore : PatDefOrDcl (variables), TmplDef (classes, traits), TypeDefOrDcl (type definitions), FunDefOrDcl (functions).",
              "name": "ignoreTokenTypes",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "anydoc",
              "description": "Force indent style: Possible values: scaladoc - 2 spaces before *, javadoc - 1 space before *.",
              "name": "indentStyle",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ScalaDocChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a string literal does not appear multiple times.*\n\nCode duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.",
          "key": "org.scalastyle.scalariform.MultipleStringLiteralsChecker-template",
          "name": "Multiple string literals",
          "params": [
            {
              "default": "1",
              "description": "Maximum occurences allowed: Maximum number of occurences allowed.",
              "name": "allowed",
              "typ": "Integer"
            },
            {
              "default": "^\"\"$",
              "description": "Ignore regular expression: Regular expression to ignore.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a string literal does not appear multiple times.*\n\nCode duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.",
          "key": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
          "name": "Multiple string literals",
          "params": [
            {
              "default": "1",
              "description": "Maximum occurences allowed: Maximum number of occurences allowed.",
              "name": "allowed",
              "typ": "Integer"
            },
            {
              "default": "^\"\"$",
              "description": "Ignore regular expression: Regular expression to ignore.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a file ends with a newline character.*\n\nSome version control systems don't cope well with files which don't end with a newline character.",
          "key": "org.scalastyle.file.NewLineAtEofChecker",
          "name": "Newline at EOF",
          "params": [
            {
              "default": "org.scalastyle.file.NewLineAtEofChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a file does not end with a newline character.*\n\nBecause Mirco Dotta wanted it.",
          "key": "org.scalastyle.file.NoNewLineAtEofChecker",
          "name": "No Newline at EOF",
          "params": [
            {
              "default": "org.scalastyle.file.NoNewLineAtEofChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that classes and objects do not define mutable fields.*\n\n`var` (mutable fields) are deprecated if you're using a strict functional style.",
          "key": "org.scalastyle.scalariform.VarFieldChecker",
          "name": "No mutable fields",
          "params": [
            {
              "default": "org.scalastyle.scalariform.VarFieldChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that functions do not define mutable variables.*\n\n`var` (mutable local variables) are deprecated if you're using a strict functional style.",
          "key": "org.scalastyle.scalariform.VarLocalChecker",
          "name": "No mutable local variables",
          "params": [
            {
              "default": "org.scalastyle.scalariform.VarLocalChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that if expressions are not redundant, i.e. easily replaced by a variant of the condition.*\n\nIf expressions with boolean constants in both branches can be eliminated without affecting readability. Prefer simply `cond` to `if (cond) true else false` and `!cond` to `if (cond) false else true`.",
          "key": "org.scalastyle.scalariform.RedundantIfChecker",
          "name": "No redundant if expressions",
          "params": [
            {
              "default": "org.scalastyle.scalariform.RedundantIfChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Ensure single space after certain token(s).*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.EnsureSingleSpaceAfterTokenChecker",
          "name": "No space after tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EnsureSingleSpaceAfterTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Ensure single space before certain token(s).*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker",
          "name": "No space before tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that Java @Deprecated is not used, Scala @deprecated should be used instead.*\n\nYou should be using the Scala `@deprecated` instead.",
          "key": "org.scalastyle.scalariform.DeprecatedJavaChecker",
          "name": "No use of Java @Deprecated",
          "params": [
            {
              "default": "org.scalastyle.scalariform.DeprecatedJavaChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that Java @Override is not used.*\n\nYou should be using the Scala override keyword instead.",
          "key": "org.scalastyle.scalariform.OverrideJavaChecker",
          "name": "No use of Java @Override",
          "params": [
            {
              "default": "org.scalastyle.scalariform.OverrideJavaChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that while is not used.*\n\n`while` loops are deprecated if you're using a strict functional style.",
          "key": "org.scalastyle.scalariform.WhileChecker",
          "name": "No while loops",
          "params": [
            {
              "default": "org.scalastyle.scalariform.WhileChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*No whitespace after left bracket ''[''.*\n\nIf there is whitespace after a left bracket, this can be confusing to the reader.",
          "key": "org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker",
          "name": "No whitespace after left bracket ''[''",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*No whitespace before left bracket ''[''.*\n\nIf there is whitespace before a left bracket, this can be confusing to the reader.",
          "key": "org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker",
          "name": "No whitespace before left bracket ''[''",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*No whitespace before right bracket '']''.*\n\nIf there is whitespace before a right bracket, this can be confusing to the reader.",
          "key": "org.scalastyle.scalariform.NoWhitespaceBeforeRightBracketChecker",
          "name": "No whitespace before right bracket '']''",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoWhitespaceBeforeRightBracketChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Some editors are unfriendly to non ASCII characters.*\n\nScala allows unicode characters as operators and some editors misbehave when they see non-ascii character. In a project collaborated by a community of developers. This check can be helpful in such situations. \n\n```scala\n\"value\" match {\n  case \"value\" => println(\"matched\")\n  ...\n}\n```\n\nis preferred to\n\n```scala\n\"value\" match {\n  case \"value\" ⇒ println(\"matched\")\n  ...\n}\n```\n\nTo fix it, replace the (unicode operator) `⇒` with `=>`.",
          "key": "org.scalastyle.scalariform.NonASCIICharacterChecker-template",
          "name": "Non ASCII characters are not allowed",
          "params": [
            {
              "default": "false",
              "description": "Allow non-ASCII scripts in string literals.: White lists Unicode characters recognized by `\\p'{'Alnum'}'\\p'{'Punct'}'\\p'{'Sc'}'\\p'{'Space'}'` but not symbols like Emoji.",
              "name": "allowStringLiterals",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.NonASCIICharacterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Some editors are unfriendly to non ASCII characters.*\n\nScala allows unicode characters as operators and some editors misbehave when they see non-ascii character. In a project collaborated by a community of developers. This check can be helpful in such situations. \n\n```scala\n\"value\" match {\n  case \"value\" => println(\"matched\")\n  ...\n}\n```\n\nis preferred to\n\n```scala\n\"value\" match {\n  case \"value\" ⇒ println(\"matched\")\n  ...\n}\n```\n\nTo fix it, replace the (unicode operator) `⇒` with `=>`.",
          "key": "org.scalastyle.scalariform.NonASCIICharacterChecker",
          "name": "Non ASCII characters are not allowed",
          "params": [
            {
              "default": "false",
              "description": "Allow non-ASCII scripts in string literals.: White lists Unicode characters recognized by `\\p'{'Alnum'}'\\p'{'Punct'}'\\p'{'Sc'}'\\p'{'Space'}'` but not symbols like Emoji.",
              "name": "allowStringLiterals",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.NonASCIICharacterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that null is not used.*\n\nScala discourages use of `null`, preferring `Option`.",
          "key": "org.scalastyle.scalariform.NullChecker-template",
          "name": "Null",
          "params": [
            {
              "default": "true",
              "description": "Allow null checks: Allow occurrences in checks like 'x == null' or 'x != null'.",
              "name": "allowNullChecks",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.NullChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that null is not used.*\n\nScala discourages use of `null`, preferring `Option`.",
          "key": "org.scalastyle.scalariform.NullChecker",
          "name": "Null",
          "params": [
            {
              "default": "true",
              "description": "Allow null checks: Allow occurrences in checks like 'x == null' or 'x != null'.",
              "name": "allowNullChecks",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.NullChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that a class / trait / object does not have too many methods.*\n\nIf a type declares too many methods, this can be an indication of bad design.",
          "key": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker-template",
          "name": "Number of methods in type",
          "params": [
            {
              "default": "30",
              "description": "Maximum methods: The maximum number of methods allowed.",
              "name": "maxMethods",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that a class / trait / object does not have too many methods.*\n\nIf a type declares too many methods, this can be an indication of bad design.",
          "key": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
          "name": "Number of methods in type",
          "params": [
            {
              "default": "30",
              "description": "Maximum methods: The maximum number of methods allowed.",
              "name": "maxMethods",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that there are not too many types declared in a file.*\n\nIf there are too many classes/objects defined in a single file, this can cause the code to be difficult to understand.",
          "key": "org.scalastyle.scalariform.NumberOfTypesChecker-template",
          "name": "Number of types",
          "params": [
            {
              "default": "20",
              "description": "Maximum Number: Maximum number of types to allow.",
              "name": "maxTypes",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfTypesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that there are not too many types declared in a file.*\n\nIf there are too many classes/objects defined in a single file, this can cause the code to be difficult to understand.",
          "key": "org.scalastyle.scalariform.NumberOfTypesChecker",
          "name": "Number of types",
          "params": [
            {
              "default": "20",
              "description": "Maximum Number: Maximum number of types to allow.",
              "name": "maxTypes",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfTypesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that object names match a regular expression.*\n\nThe Scala style guide recommends that object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ObjectNamesChecker-template",
          "name": "Object name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The object names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that object names match a regular expression.*\n\nThe Scala style guide recommends that object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ObjectNamesChecker",
          "name": "Object name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The object names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that braces aren't used in case clauses.*\n\nBraces aren't required in case clauses. They should be omitted according to Scala Style Guide.",
          "key": "org.scalastyle.scalariform.CaseBraceChecker",
          "name": "Omit braces in case clauses",
          "params": [
            {
              "default": "org.scalastyle.scalariform.CaseBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that package names match a regular expression.*\n\nThe Scala style guide recommends that package names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageNamesChecker-template",
          "name": "Package name",
          "params": [
            {
              "default": "^[a-z]+$",
              "description": "Regular expression: The package names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that package names match a regular expression.*\n\nThe Scala style guide recommends that package names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageNamesChecker",
          "name": "Package name",
          "params": [
            {
              "default": "^[a-z]+$",
              "description": "Regular expression: The package names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that package object names match a regular expression.*\n\nThe Scala style guide recommends that package object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageObjectNamesChecker-template",
          "name": "Package object name",
          "params": [
            {
              "default": "^[a-z][A-Za-z]*$",
              "description": "Regular expression: The package object names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that package object names match a regular expression.*\n\nThe Scala style guide recommends that package object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageObjectNamesChecker",
          "name": "Package object name",
          "params": [
            {
              "default": "^[a-z][A-Za-z]*$",
              "description": "Regular expression: The package object names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that pattern match arrows align.*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.PatternMatchAlignChecker",
          "name": "Pattern match align",
          "params": [
            {
              "default": "org.scalastyle.scalariform.PatternMatchAlignChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that a method has an explicit return type, it is not inferred.*\n\nA public method declared on a type is effectively an API declaration. Explicitly declaring a return type means that other code which depends on that type won't break unexpectedly.",
          "key": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker-template",
          "name": "Public method must have type",
          "params": [
            {
              "default": "false",
              "description": "Ignore overridden methods: If true, public methods which override are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that a method has an explicit return type, it is not inferred.*\n\nA public method declared on a type is effectively an API declaration. Explicitly declaring a return type means that other code which depends on that type won't break unexpectedly.",
          "key": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
          "name": "Public method must have type",
          "params": [
            {
              "default": "false",
              "description": "Ignore overridden methods: If true, public methods which override are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*If a class/trait has no members, the braces are unnecessary.*\n\nIf a `class` / `trait` has no members, then braces are unnecessary, and can be removed.",
          "key": "org.scalastyle.scalariform.EmptyClassChecker",
          "name": "Redundant braces in class definition",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EmptyClassChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a regular expression cannot be matched, if found reports this.*\n\nSome checks can be carried out with a regular expression.",
          "key": "org.scalastyle.file.RegexChecker-template",
          "name": "Regular expression",
          "params": [
            {
              "default": "",
              "description": "Regular expression: Standard Scala regular expression syntax including multiline.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Line: Boolean whether to process line by line.",
              "name": "line",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.RegexChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a regular expression cannot be matched in a token, if found reports this.*\n\nSome checks can be carried by just the presence of a particular token.",
          "key": "org.scalastyle.scalariform.TokenChecker-template",
          "name": "Regular expression in a token",
          "params": [
            {
              "default": "^$",
              "description": "Regular expression: Standard Scala regular expression syntax.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a regular expression cannot be matched in a token, if found reports this.*\n\nSome checks can be carried by just the presence of a particular token.",
          "key": "org.scalastyle.scalariform.TokenChecker",
          "name": "Regular expression in a token",
          "params": [
            {
              "default": "^$",
              "description": "Regular expression: Standard Scala regular expression syntax.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that return is not used.*\n\nUse of `return` is not usually necessary in Scala. In fact, use of return can discourage a functional style of programming.",
          "key": "org.scalastyle.scalariform.ReturnChecker",
          "name": "Return",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ReturnChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Boolean expression can be simplified.*\n\nA boolean expression which can be simplified can make code easier to read.",
          "key": "org.scalastyle.scalariform.SimplifyBooleanExpressionChecker",
          "name": "Simplify Boolean expression",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SimplifyBooleanExpressionChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that the plus sign is followed by a space.*\n\nAn expression with spaces around `+` can be easier to read.",
          "key": "org.scalastyle.scalariform.SpacesAfterPlusChecker",
          "name": "Space after plus",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SpacesAfterPlusChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks a space after the start of the comment.*\n\nTo bring consistency with how comments should be formatted, leave a space right after the beginning of the comment.\n\n```scala\npackage foobar\n\nobject Foobar {\n  /**WRONG\n    *\n    */\n  /** Correct\n    *\n    */\n  val d = 2 /*Wrong*/ //Wrong\n  /**\n    * Correct\n    */\n  val e = 3 /** Correct*/ // Correct\n}\n```",
          "key": "org.scalastyle.scalariform.SpaceAfterCommentStartChecker",
          "name": "Space after the start of the comment",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SpaceAfterCommentStartChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Disallow space after certain token(s).*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.DisallowSpaceAfterTokenChecker",
          "name": "Space after tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.DisallowSpaceAfterTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that the plus sign is preceded by a space.*\n\nAn expression with spaces around `+` can be easier to read.",
          "key": "org.scalastyle.scalariform.SpacesBeforePlusChecker",
          "name": "Space before plus",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SpacesBeforePlusChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Disallow space before certain token(s).*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.DisallowSpaceBeforeTokenChecker",
          "name": "Space before tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.DisallowSpaceBeforeTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that structural types are not used.*\n\nStructural types in Scala can use reflection - this can have unexpected performance consequences. Warning: This check can also wrongly pick up type lamdbas and other such constructs. This checker should be used with care. You always have the alternative of the scalac checking for structural types.",
          "key": "org.scalastyle.scalariform.StructuralTypeChecker",
          "name": "Structural type",
          "params": [
            {
              "default": "org.scalastyle.scalariform.StructuralTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check for use of TODO/FIXME single line comments.*\n\nSome projects may consider `TODO` or `FIXME` comments in a code bad style. They would rather you fix the problem.",
          "key": "org.scalastyle.scalariform.TodoCommentChecker-template",
          "name": "TODO/FIXME comment",
          "params": [
            {
              "default": "TODO|FIXME",
              "description": "Word list: Alternative list of words to look for, separated by |.",
              "name": "words",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TodoCommentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check for use of TODO/FIXME single line comments.*\n\nSome projects may consider `TODO` or `FIXME` comments in a code bad style. They would rather you fix the problem.",
          "key": "org.scalastyle.scalariform.TodoCommentChecker",
          "name": "TODO/FIXME comment",
          "params": [
            {
              "default": "TODO|FIXME",
              "description": "Word list: Alternative list of words to look for, separated by |.",
              "name": "words",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TodoCommentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that the code does not have ??? operators.*\n\nThe `???` operator denotes that an implementation is missing. This rule helps to avoid potential runtime errors because of not implemented code.",
          "key": "org.scalastyle.scalariform.NotImplementedErrorUsage",
          "name": "Usage of ??? operator",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NotImplementedErrorUsage",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Use a : Unit = for procedure declarations.*\n\nA procedure style declaration can cause confusion - the developer may have simply forgotten to add a `=`, and now their method returns `Unit` rather than the inferred type:\n\n```scala\ndef foo() { println(\"hello\"); 5 }\n```\nThis checker raises a warning with the first line. To fix it, use an explicit return type, or add a `=` before the body.\n\n```scala\ndef foo() = { println(\"hello\"); 5 }\n```",
          "key": "org.scalastyle.scalariform.ProcedureDeclarationChecker",
          "name": "Use : Unit = for procedures",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ProcedureDeclarationChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that braces are used in for comprehensions.*\n\nUsage of braces (rather than parentheses) within a `for` comprehension mean that you don't have to specify a semi-colon at the end of every line:\n\n```scala\nfor { // braces\n  t <- List(1,2,3)\n  if (t % 2 == 0)\n} yield t\n```\n\nis preferred to\n\n```scala\nfor ( // parentheses\n  t <- List(1,2,3);\n  if (t % 2 == 0)\n) yield t\n```\n\nTo fix it, replace the `()` with `{}`. And then remove the `;` at the end of the lines.\n\nThe `singleLineAllowed` property allows for constructions of the type:\n\n```scala\nfor (i <- List(1,2,3)) yield i\n```",
          "key": "org.scalastyle.scalariform.ForBraceChecker-template",
          "name": "Use braces in for comprehensions",
          "params": [
            {
              "default": "false",
              "description": "Allow parentheses for single-line for: For with parentheses allowed if everything is on one line.",
              "name": "singleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.ForBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that braces are used in for comprehensions.*\n\nUsage of braces (rather than parentheses) within a `for` comprehension mean that you don't have to specify a semi-colon at the end of every line:\n\n```scala\nfor { // braces\n  t <- List(1,2,3)\n  if (t % 2 == 0)\n} yield t\n```\n\nis preferred to\n\n```scala\nfor ( // parentheses\n  t <- List(1,2,3);\n  if (t % 2 == 0)\n) yield t\n```\n\nTo fix it, replace the `()` with `{}`. And then remove the `;` at the end of the lines.\n\nThe `singleLineAllowed` property allows for constructions of the type:\n\n```scala\nfor (i <- List(1,2,3)) yield i\n```",
          "key": "org.scalastyle.scalariform.ForBraceChecker",
          "name": "Use braces in for comprehensions",
          "params": [
            {
              "default": "false",
              "description": "Allow parentheses for single-line for: For with parentheses allowed if everything is on one line.",
              "name": "singleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.ForBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that lines are indented by a multiple of the tab size.*\n\nCode that is not indented consistently can be hard to read.",
          "key": "org.scalastyle.file.IndentationChecker-template",
          "name": "Use correct indentation",
          "params": [
            {
              "default": "2",
              "description": "Tab size: Number of characters that a tab represents.",
              "name": "tabSize",
              "typ": "Integer"
            },
            {
              "default": "2",
              "description": "Multi-line method parameter spacing: Level of indentation of multi-line method parameters relative to the indentation of the first line of the method.",
              "name": "methodParamIndentSize",
              "typ": "Integer"
            },
            {
              "default": "4",
              "description": "Multi-line class parameter spacing: Level of indentation of multi-line primary constructor parameters of a class. Relative to the indentation of the first line of class declaration.",
              "name": "classParamIndentSize",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.file.IndentationChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that lines are indented by a multiple of the tab size.*\n\nCode that is not indented consistently can be hard to read.",
          "key": "org.scalastyle.file.IndentationChecker",
          "name": "Use correct indentation",
          "params": [
            {
              "default": "2",
              "description": "Tab size: Number of characters that a tab represents.",
              "name": "tabSize",
              "typ": "Integer"
            },
            {
              "default": "2",
              "description": "Multi-line method parameter spacing: Level of indentation of multi-line method parameters relative to the indentation of the first line of the method.",
              "name": "methodParamIndentSize",
              "typ": "Integer"
            },
            {
              "default": "4",
              "description": "Multi-line class parameter spacing: Level of indentation of multi-line primary constructor parameters of a class. Relative to the indentation of the first line of class declaration.",
              "name": "classParamIndentSize",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.file.IndentationChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that parentheses are used in for loops.*\n\nFor-comprehensions which lack a `yield` clause is actually a loop rather than a functional comprehension and it is usually more readable to string the generators together between parentheses rather than using the syntactically-confusing `} {` construct:\n\n```scala\nfor (x <- board.rows; y <- board.files) {\n  printf(\"(%d, %d)\", x, y)\n}\n```\n\nis preferred to\n\n```scala\nfor {\n  x <- board.rows\n  y <- board.files\n} {\n  printf(\"(%d, %d)\", x, y)\n}\n```",
          "key": "org.scalastyle.scalariform.ForLoopChecker",
          "name": "Use parentheses in for loops",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ForLoopChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that while body have braces.*\n\nWhile cannot be used in a pure-functional manner, that's why it's recommended to never omit braces according to Scala Style Guide.",
          "key": "org.scalastyle.scalariform.WhileBraceChecker",
          "name": "While body should have braces",
          "params": [
            {
              "default": "org.scalastyle.scalariform.WhileBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that there is no trailing whitespace at the end of lines.*\n\nWhitespace at the end of a line can cause problems when diffing between files or between versions.",
          "key": "org.scalastyle.file.WhitespaceEndOfLineChecker-template",
          "name": "Whitespace at end of line",
          "params": [
            {
              "default": "false",
              "description": "Ignore lines with just whitespace: Skip a line if the entire contents are whitespace characters.",
              "name": "ignoreWhitespaceLines",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.WhitespaceEndOfLineChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that there is no trailing whitespace at the end of lines.*\n\nWhitespace at the end of a line can cause problems when diffing between files or between versions.",
          "key": "org.scalastyle.file.WhitespaceEndOfLineChecker",
          "name": "Whitespace at end of line",
          "params": [
            {
              "default": "false",
              "description": "Ignore lines with just whitespace: Skip a line if the entire contents are whitespace characters.",
              "name": "ignoreWhitespaceLines",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.WhitespaceEndOfLineChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that XML literals are not used.*\n\nSome projects prefer not to have XML literals. They could use a templating engine instead.",
          "key": "org.scalastyle.scalariform.XmlLiteralChecker",
          "name": "XML literals",
          "params": [
            {
              "default": "org.scalastyle.scalariform.XmlLiteralChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        }
      ]
    },
    "sonar-scala-scapegoat": {
      "key": "sonar-scala-scapegoat",
      "name": "Scapegoat",
      "rules": [
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.NegationIsEmpty",
          "name": "!isEmpty can be replaced with nonEmpty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.NegationNonEmpty",
          "name": "!nonEmpty can be replaced with isEmpty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "Array equals is not an equality check. Use a.deep == b.deep or convert to another collection type",
          "key": "com.sksamuel.scapegoat.inspections.collections.ArrayEquals",
          "name": "Array equals",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.string.ArraysInFormat",
          "name": "Array passed to String.format",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.AvoidToMinusOne",
          "name": "Avoid To Minus One",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.AvoidSizeNotEqualsZero",
          "name": "Avoid Traversable.size != 0, use Traversable.nonEmpty instead",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.AvoidSizeEqualsZero",
          "name": "Avoid Traversable.size == 0, use Traversable.isEmpty instead",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.style.AvoidOperatorOverload",
          "name": "Avoid operator overload",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.math.BigDecimalDoubleConstructor",
          "name": "Big decimal double constructor",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "When using setScale() on a BigDecimal without setting the rounding mode, this can throw an exception if rounding is required. Did you mean to call setScale(s, RoundingMode.XYZ)",
          "key": "com.sksamuel.scapegoat.inspections.math.BigDecimalScaleWithoutRoundingMode",
          "name": "BigDecimal setScale() without rounding mode",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.inference.BoundedByFinalType",
          "name": "Bounded by final type",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.math.BrokenOddness",
          "name": "Broken odd check",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.exception.CatchException",
          "name": "Catch exception",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.exception.CatchFatal",
          "name": "Catch fatal exception",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.exception.CatchThrowable",
          "name": "Catch throwable",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.exception.CatchNpe",
          "name": "Catching NPE",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.naming.ClassNames",
          "name": "Class name not recommended",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.CollectionNegativeIndex",
          "name": "Collection index out of bounds",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.CollectionNamingConfusion",
          "name": "Collection naming Confusion",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.CollectionPromotionToAny",
          "name": "Collection promotion to any",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.equality.ComparingUnrelatedTypes",
          "name": "Comparing unrelated types",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "Comparision with self will always yield true",
          "key": "com.sksamuel.scapegoat.inspections.equality.ComparisonWithSelf",
          "name": "Comparision with self",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.ComparisonToEmptyList",
          "name": "Comparison to empty list",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.ComparisonToEmptySet",
          "name": "Comparison to empty set",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.ConstantIf",
          "name": "Constant if expression",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "Divide by one will always return the original value",
          "key": "com.sksamuel.scapegoat.inspections.math.DivideByOne",
          "name": "Divide by one",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.DoubleNegation",
          "name": "Double negation",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.imports.DuplicateImport",
          "name": "Duplicated Import",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.DuplicateMapKey",
          "name": "Duplicated map key",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.DuplicateSetValue",
          "name": "Duplicated set value",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "Empty case class can be rewritten as a case object",
          "key": "com.sksamuel.scapegoat.inspections.EmptyCaseClass",
          "name": "Empty case class",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.exception.SwallowedException",
          "name": "Empty catch block",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyFor",
          "name": "Empty for loop",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyIfBlock",
          "name": "Empty if statement",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.string.EmptyInterpolatedString",
          "name": "Empty interpolated string",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyMethod",
          "name": "Empty method",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptySynchronizedBlock",
          "name": "Empty synchronized block",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyTryBlock",
          "name": "Empty try block",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyWhileBlock",
          "name": "Empty while block",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.ExistsSimplifiableToContains",
          "name": "Exists simplifiable to contains",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "Finalizers should call super.finalize() to ensure superclasses are able to run any finalization logic",
          "key": "com.sksamuel.scapegoat.inspections.unsafe.FinalizerWithoutSuper",
          "name": "Finalizer without super",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.equality.ComparingFloatingPointTypes",
          "name": "Floating type comparison",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.string.IllegalFormatString",
          "name": "Illegal format string",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.option.ImpossibleOptionSizeCondition",
          "name": "Impossible Option.size condition",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.string.IncorrectNumberOfArgsToFormat",
          "name": "Incorrect number of args for format",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.exception.IncorrectlyNamedExceptions",
          "name": "Incorrectly Named Exceptions",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.math.ModOne",
          "name": "Integer mod one",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.string.InvalidRegex",
          "name": "Invalid regex",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "Use of java conversions can lead to unusual behaviour. It is recommended to use JavaConverters",
          "key": "com.sksamuel.scapegoat.inspections.collections.JavaConversionsUse",
          "name": "Java conversions",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "List append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer or Vector and converting to a List once built.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ListAppend",
          "name": "List append is slow",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or Array.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ListSize",
          "name": "List.size is O(n)",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.LonelySealedTrait",
          "name": "Lonely sealed trait",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.string.LooksLikeInterpolatedString",
          "name": "Looks Like Interpolated String",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.matching.PartialFunctionInsteadOfMatch",
          "name": "Match instead of partial function",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.MaxParameters",
          "name": "Max parameters",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.inference.MethodReturningAny",
          "name": "Method Returning Any",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods",
          "key": "com.sksamuel.scapegoat.inspections.naming.MethodNames",
          "name": "Method name not recommended",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "Case classes should have final modifier",
          "key": "com.sksamuel.scapegoat.inspections.FinalModifierOnCaseClass",
          "name": "Missing final modifier on case class",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "NaN comparision will always fail. Use value.isNan instead.",
          "key": "com.sksamuel.scapegoat.inspections.math.NanComparison",
          "name": "Nan comparision",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.NoOpOverride",
          "name": "No op Override",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.nulls.NullAssignment",
          "name": "Null assignment",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.nulls.NullParameter",
          "name": "Null parameter",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.naming.ObjectNames",
          "name": "Object name not recommended",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.style.ParameterlessMethodReturnsUnit",
          "name": "Parameterless methods returns unit",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.inference.PointlessTypeBounds",
          "name": "Pointless Type Bounds",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.PreferMapEmpty",
          "name": "Prefer Map.empty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.option.OptionSize",
          "name": "Prefer Option.isDefined instead of Option.size",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.PreferSeqEmpty",
          "name": "Prefer Seq.empty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.PreferSetEmpty",
          "name": "Prefer Set.empty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.inference.ProductWithSerializableInferred",
          "name": "Product with Serializable inferred",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "Public finalizer should be avoided as finalizers should not be programatically invoked",
          "key": "com.sksamuel.scapegoat.inspections.PublicFinalizer",
          "name": "PublicFinalizer",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.RedundantFinalModifierOnMethod",
          "name": "Redundant final modifier on method",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "This var cannot be overridden, final modifier is redundant",
          "key": "com.sksamuel.scapegoat.inspections.RedundantFinalModifierOnVar",
          "name": "Redundant final modifier on var",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.RedundantFinalizer",
          "name": "Redundant finalizer",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.matching.RepeatedCaseBody",
          "name": "Repeated case body",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.CollectionIndexOnNonIndexedSeq",
          "name": "Seq.apply() on a non-IndexedSeq may cause performance problems",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.style.SimplifyBooleanExpression",
          "name": "Simplify boolean expressions",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.string.SubstringZero",
          "name": "String.substring(0)",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "Strip margin will strip | from regex - possible corrupted regex",
          "key": "com.sksamuel.scapegoat.inspections.string.StripMarginOnRegex",
          "name": "Strip margin on regex",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.matching.SuspiciousMatchOnClassObject",
          "name": "Suspicious match on class object",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.SwapSortFilter",
          "name": "Swap sort filter",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.TypeShadowing",
          "name": "Type shadowing",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryConversion",
          "name": "Unnecessary conversion",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryIf",
          "name": "Unnecessary if condition.",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "Scala returns the value of the last expression in a block. Use of return here is not idiomatic scala",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryReturnUse",
          "name": "Unnecessary return",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.ReverseFunc",
          "name": "Unnecessary reverse",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.exception.UnreachableCatch",
          "name": "Unreachable catch",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.UnsafeContains",
          "name": "Unsafe contains",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.string.UnsafeStringContains",
          "name": "Unsafe string contains",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnusedMethodParameter",
          "name": "Unused parameter",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.math.UseCbrt",
          "name": "Use cbrt",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.math.UseExpM1",
          "name": "Use expm1",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.math.UseLog10",
          "name": "Use log10",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.math.UseLog1P",
          "name": "Use log1p",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.MapGetAndGetOrElse",
          "name": "Use of .get.getOrElse instead of .getOrElse",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.string.ArraysToString",
          "name": "Use of Array.toString",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.option.EitherGet",
          "name": "Use of Either Right or Left Projection get",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.option.OptionGet",
          "name": "Use of Option.get",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.unsafe.TryGet",
          "name": "Use of Try.get",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.unsafe.AsInstanceOf",
          "name": "Use of asInstanceOf",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.unsafe.IsInstanceOf",
          "name": "Use of isInstanceOf",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.UnsafeTraversableMethods",
          "name": "Use of unsafe Traversable methods (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy)",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.math.UseSqrt",
          "name": "Use sqrt",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.VarCouldBeVal",
          "name": "Var could be val",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.VarClosure",
          "name": "Var in closure",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.controlflow.WhileTrue",
          "name": "While true loop",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "Dividing zero by any number will always return zero",
          "key": "com.sksamuel.scapegoat.inspections.math.ZeroNumerator",
          "name": "Zero numerator",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotHead",
          "name": "filter().head can throw an exception; use find()",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotHeadOption",
          "name": "filter().headOption instead of find()",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotIsEmpty",
          "name": "filter().isEmpty instead of !exists()",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotSize",
          "name": "filter().size() instead of count()",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterOptionAndGet",
          "name": "filter(_.isDefined).map(_.get) instead of flatten",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.FindAndNotEqualsNoneReplaceWithExists",
          "name": "find(x => ) != None instead of exists(x =>)",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.ReverseTailReverse",
          "name": "reverse.tail.reverse instead of init",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.ReverseTakeReverse",
          "name": "reverse.take(...).reverse instead of takeRight",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "",
          "key": "com.sksamuel.scapegoat.inspections.collections.FindDotIsDefined",
          "name": "use exists() not find().isDefined()",
          "params": [],
          "severity": "Info",
          "template": false
        }
      ]
    }
  },
  "rules": {
    "scalastyle": [
      {
        "description": "*Checks that block imports are not used.*\n\nBlock imports, e.g. `import a.{b, c}` can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports are used in order to minimize merge errors in import declarations.",
        "key": "org.scalastyle.scalariform.BlockImportChecker",
        "name": "Avoid block imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that curlies imports are not used.*\n\nCurlies imports, e.g. `import a.{b, c}`, can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports, no renaming and no hiding imports are used in order to minimize merge errors in import declarations.",
        "key": "org.scalastyle.scalariform.CurliesImportChecker",
        "name": "Avoid curlies imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Avoid wildcard imports.*\n\nImporting all classes from a package or static members from a class leads to tight coupling between packages or classes and might lead to problems when a new version of a library introduces name clashes.",
        "key": "org.scalastyle.scalariform.UnderscoreImportChecker",
        "name": "Avoid wildcard imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that class names match a regular expression.*\n\nThe Scala style guide recommends that class names conform to certain standards.",
        "key": "org.scalastyle.scalariform.ClassNamesChecker",
        "name": "Class name",
        "params": [
          {
            "default": "^[A-Z][A-Za-z]*$",
            "description": "Regular expression: The class names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that type parameter to a class matches a regular expression.*\n\nScala generic type names are generally single upper case letters. This check checks for classes and traits. Note that this check only checks the innermost type parameter, to allow for `List[T]`.",
        "key": "org.scalastyle.scalariform.ClassTypeParameterChecker",
        "name": "Class type parameter name",
        "params": [
          {
            "default": "^[A-Z_]$",
            "description": "Regular expression: Standard Scala regular expression syntax.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that classes and objects do not define the clone() method.*\n\nThe clone method is difficult to get right. You can use the copy constructor of case classes rather than implementing clone. For more information on `clone()`, see Effective Java by Joshua Bloch pages.",
        "key": "org.scalastyle.scalariform.NoCloneChecker",
        "name": "Clone method",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that classes and objects do not define equals without overriding equals(java.lang.Object).*\n\nMistakenly defining a covariant `equals()` method without overriding method `equals(java.lang.Object)` can produce unexpected runtime behaviour.",
        "key": "org.scalastyle.scalariform.CovariantEqualsChecker",
        "name": "Covariant equals",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that the cyclomatic complexity of a method does exceed a value.*\n\nIf the code is too complex, then this can make code hard to read.",
        "key": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
        "name": "Cyclomatic complexity",
        "params": [
          {
            "default": "10",
            "description": "Maximum: Maximum cyclomatic complexity to allow for a method.",
            "name": "maximum",
            "typ": "Integer"
          },
          {
            "default": "true",
            "description": "Count Cases: If true, each case increases method complexity, else only match keyword is considered.",
            "name": "countCases",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*The interpolation for this string literal is not necessary.*\n\nEmpty interpolated strings are harder to read and not necessary.",
        "key": "org.scalastyle.scalariform.EmptyInterpolatedStringChecker",
        "name": "Empty interpolated string",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that if a class implements either equals or hashCode, it should implement the other.*\n\nDefining either equals or hashCode in a class without defining the is a known source of bugs. Usually, when you define one, you should also define the other.",
        "key": "org.scalastyle.scalariform.EqualsHashCodeChecker",
        "name": "Equals hashCode",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that field names match a regular expression.*\n\nA consistent naming convention for field names can make code easier to read and understand.",
        "key": "org.scalastyle.scalariform.FieldNamesChecker",
        "name": "Field name",
        "params": [
          {
            "default": "^[a-z][A-Za-z0-9]*$",
            "description": "Regular expression: The field names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "^[A-Z][A-Za-z0-9]*$",
            "description": "Regular expression for constants: The object field (constant) names must match this regular expression.",
            "name": "objectFieldRegex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check the number of lines in a file.*\n\nFiles which are too long can be hard to read and understand.",
        "key": "org.scalastyle.file.FileLengthChecker",
        "name": "File length",
        "params": [
          {
            "default": "1500",
            "description": "Maximum file length: Maximum number of lines in a file.",
            "name": "maxFileLength",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check the number of characters in a line.*\n\nLines that are too long can be hard to read and horizontal scrolling is annoying.",
        "key": "org.scalastyle.file.FileLineLengthChecker",
        "name": "File line length",
        "params": [
          {
            "default": "160",
            "description": "Maximum line length: Maximum number of characters in a line.",
            "name": "maxLineLength",
            "typ": "Integer"
          },
          {
            "default": "4",
            "description": "Tab size: Number of characters that a tab represents.",
            "name": "tabSize",
            "typ": "Integer"
          },
          {
            "default": "false",
            "description": "Ignore import statements: Ignore import statements.",
            "name": "ignoreImports",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that classes and objects do not define the finalize() method.*\n\n`finalize()` is called when the object is garbage collected, and garbage collection is not guaranteed to happen. It is therefore unwise to rely on code in `finalize()` method.",
        "key": "org.scalastyle.scalariform.NoFinalizeChecker",
        "name": "Finalize method",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that imports are grouped together, not throughout the file.*\n\nIf imports are spread throughout the file, knowing what is in scope at any one place can be difficult to work out.",
        "key": "org.scalastyle.scalariform.ImportGroupingChecker",
        "name": "Group imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that if statements have braces.*\n\nSome people find if clauses with braces easier to read.\n\nThe `singleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nThe `doubleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nNote: If you intend to enable only if expressions in the format below, disable the IfBraceChecker altogether.\n\n```scala\nif (bool_expression) expression1 else expression2\n```",
        "key": "org.scalastyle.scalariform.IfBraceChecker",
        "name": "If block braces",
        "params": [
          {
            "default": "true",
            "description": "Single Line Allowed: If without braces allowed if everything is on one line.",
            "name": "singleLineAllowed",
            "typ": "Boolean"
          },
          {
            "default": "false",
            "description": "Double Line Allowed: If without braces allowed if everything is on one line or two lines.",
            "name": "doubleLineAllowed",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that a class does not import certain classes.*\n\nUse of some classes can be discouraged for a project. For instance, use of `sun._` is generally discouraged because they are internal to the JDK and can be changed.",
        "key": "org.scalastyle.scalariform.IllegalImportsChecker",
        "name": "Illegal imports",
        "params": [
          {
            "default": "sun._,java.awt._",
            "description": "Illegal Imports: The comma separated list of illegal imports, wildcards allowed.",
            "name": "illegalImports",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that imports are grouped and ordered according to the style configuration.*\n\nConsistent import ordering improves code readability and reduces unrelated changes in patches.",
        "key": "org.scalastyle.scalariform.ImportOrderChecker",
        "name": "Import Order",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that there are no tabs in a file.*\n\nSome say that tabs are evil.",
        "key": "org.scalastyle.file.FileTabChecker",
        "name": "Line contains Tab",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that argument literals are named.*\n\nNameless literals make code harder to understand (consider `updateEntity(1, true)` and `updateEntity(id = 1, enabled = true)`).",
        "key": "org.scalastyle.scalariform.NamedArgumentChecker",
        "name": "Literal passed as argument without name",
        "params": [
          {
            "default": "false",
            "description": "Check string literals: If true, also checks that string literal arguments are named.",
            "name": "checkString",
            "typ": "Boolean"
          },
          {
            "default": "^set.+$",
            "description": "Ignore methods by pattern: Pattern to ignore method calls by name.",
            "name": "ignoreMethod",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that if a long literal is used, then an uppercase L is used.*\n\nA lowercase L (l) can look similar to a number 1 with some fonts.",
        "key": "org.scalastyle.scalariform.UppercaseLChecker",
        "name": "Long literal uppercase L",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a case statement pattern match is not lower case, as this can cause confusion.*\n\nA lower case pattern match clause with no other tokens is the same as `_`; this is not true for patterns which start with an upper case letter. This can cause confusion, and may not be what was intended:\n\n```scala\nval foo = \"foo\"\nval Bar = \"bar\"\n\"bar\" match { case Bar => \"we got bar\" } // result = \"we got bar\"\n\"bar\" match { case foo => \"we got foo\" } // result = \"we got foo\"\n\"bar\" match { case `foo` => \"we got foo\" } // result = MatchError\n```\n\nThis checker raises a warning with the second match. To fix it, use an identifier which starts with an upper case letter (best), use `case _` or, if you wish to refer to the value, add a type `: Any`, e.g.:\n\n```scala\nval lc = \"lc\"\n\"something\" match { case lc: Any => \"lc\" } // result = \"lc\"\n\"something\" match { case _ => \"lc\" } // result = \"lc\"\n```",
        "key": "org.scalastyle.scalariform.LowercasePatternMatchChecker",
        "name": "Lowercase pattern match",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of magic numbers.*\n\nReplacing a magic number with a named constant can make code easier to read and understand, and can avoid some subtle bugs.\n\nA simple assignment to a val is not considered to be a magic number, for example: `val foo = 4` is not a magic number, but `var foo = 4` is considered to be a magic number.",
        "key": "org.scalastyle.scalariform.MagicNumberChecker",
        "name": "Magic Number",
        "params": [
          {
            "default": "-1,0,1,2",
            "description": "Ignore: The comma separated list of numbers to ignore when used as magic numbers.",
            "name": "ignore",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check the first lines of each file matches the text.*\n\nA lot of projects require a header with a copyright notice, or they require a license in each file. This does a simple text comparison between the header and the first lines of the file. You can have multiple lines, but make sure you surround the text with a `CDATA` section. You can also specify a regular expression, as long as you set the regex parameter to `true`.",
        "key": "org.scalastyle.file.HeaderMatchesChecker",
        "name": "Match Header",
        "params": [
          {
            "default": "",
            "description": "Header: The lines to compare against.",
            "name": "header",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Header Regex: Whether to treat the header string as a regular expression.",
            "name": "regex",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Maximum number of parameters for a method.*\n\nA method which has more than a certain number of parameters can be hard to understand.",
        "key": "org.scalastyle.scalariform.ParameterNumberChecker",
        "name": "Maximum parameters",
        "params": [
          {
            "default": "8",
            "description": "Maximum Number: The maximum number of parameters.",
            "name": "maxParameters",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that method argument names match a regular expression.*\n\nThe Scala style guide recommends that method argument names conform to certain standards.",
        "key": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
        "name": "Method argument name",
        "params": [
          {
            "default": "^[a-z][A-Za-z0-9]*$",
            "description": "Regular expression: The method argument names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "^$",
            "description": "Regular expression to ignore: Method argument names which match this regular expression will be ignored.",
            "name": "ignoreRegex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that methods do not exceed a maximum length.*\n\nLong methods can be hard to read and understand.",
        "key": "org.scalastyle.scalariform.MethodLengthChecker",
        "name": "Method length",
        "params": [
          {
            "default": "50",
            "description": "Maximum length: Maximum number of lines allowed for a method.",
            "name": "maxLength",
            "typ": "Integer"
          },
          {
            "default": "false",
            "description": "Ignore comments: If set to true, comment lines in method body won't be counted.",
            "name": "ignoreComments",
            "typ": "Boolean"
          },
          {
            "default": "false",
            "description": "Ignore empty lines: If set to true, empty lines in method body won't be counted.",
            "name": "ignoreEmpty",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that method names match a regular expression.*\n\nThe Scala style guide recommends that method names conform to certain standards. If the methods are overriding another method, and the overridden method cannot be changed, then use the `ignoreOverride` parameter.",
        "key": "org.scalastyle.scalariform.MethodNamesChecker",
        "name": "Method name",
        "params": [
          {
            "default": "^[a-z][A-Za-z0-9]*(_=)?$",
            "description": "Regular expression: The method names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "^$",
            "description": "Regular expression to ignore: Method names which match this regular expression will be ignored.",
            "name": "ignoreRegex",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
            "name": "ignoreOverride",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that the ScalaDoc on documentable members is well-formed.*\n\nScaladoc is generally considered a good thing. Within reason.\n\nIgnore tokens is a comma separated string that may include the following: `PatDefOrDcl` (variables), `TmplDef` (classes, traits), `TypeDefOrDcl` (type definitions), `FunDefOrDcl` (functions). Supported indentation styles are \"scaladoc\" (for ScalaDoc-style comments, with two spaces before the asterisk), \"javadoc\" (for JavaDoc-style comments, with a single space before the asterisk) or \"anydoc\" to support any style (any number of spaces before the asterisk). For backwards compatibility, if left empty, \"anydoc\" will be assumed.",
        "key": "org.scalastyle.scalariform.ScalaDocChecker",
        "name": "Missing or badly formed ScalaDoc",
        "params": [
          {
            "default": "^$",
            "description": "Regular expression: Class names matching this regular expression will be ignored.",
            "name": "ignoreRegex",
            "typ": "String"
          },
          {
            "default": "^$",
            "description": "Comma Separated String: Include the following to ignore : PatDefOrDcl (variables), TmplDef (classes, traits), TypeDefOrDcl (type definitions), FunDefOrDcl (functions).",
            "name": "ignoreTokenTypes",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
            "name": "ignoreOverride",
            "typ": "Boolean"
          },
          {
            "default": "anydoc",
            "description": "Force indent style: Possible values: scaladoc - 2 spaces before *, javadoc - 1 space before *.",
            "name": "indentStyle",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that a string literal does not appear multiple times.*\n\nCode duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.",
        "key": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
        "name": "Multiple string literals",
        "params": [
          {
            "default": "1",
            "description": "Maximum occurences allowed: Maximum number of occurences allowed.",
            "name": "allowed",
            "typ": "Integer"
          },
          {
            "default": "^\"\"$",
            "description": "Ignore regular expression: Regular expression to ignore.",
            "name": "ignoreRegex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that a file ends with a newline character.*\n\nSome version control systems don't cope well with files which don't end with a newline character.",
        "key": "org.scalastyle.file.NewLineAtEofChecker",
        "name": "Newline at EOF",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a file does not end with a newline character.*\n\nBecause Mirco Dotta wanted it.",
        "key": "org.scalastyle.file.NoNewLineAtEofChecker",
        "name": "No Newline at EOF",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that classes and objects do not define mutable fields.*\n\n`var` (mutable fields) are deprecated if you're using a strict functional style.",
        "key": "org.scalastyle.scalariform.VarFieldChecker",
        "name": "No mutable fields",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that functions do not define mutable variables.*\n\n`var` (mutable local variables) are deprecated if you're using a strict functional style.",
        "key": "org.scalastyle.scalariform.VarLocalChecker",
        "name": "No mutable local variables",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that if expressions are not redundant, i.e. easily replaced by a variant of the condition.*\n\nIf expressions with boolean constants in both branches can be eliminated without affecting readability. Prefer simply `cond` to `if (cond) true else false` and `!cond` to `if (cond) false else true`.",
        "key": "org.scalastyle.scalariform.RedundantIfChecker",
        "name": "No redundant if expressions",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Ensure single space after certain token(s).*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.EnsureSingleSpaceAfterTokenChecker",
        "name": "No space after tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Ensure single space before certain token(s).*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker",
        "name": "No space before tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that Java @Deprecated is not used, Scala @deprecated should be used instead.*\n\nYou should be using the Scala `@deprecated` instead.",
        "key": "org.scalastyle.scalariform.DeprecatedJavaChecker",
        "name": "No use of Java @Deprecated",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that Java @Override is not used.*\n\nYou should be using the Scala override keyword instead.",
        "key": "org.scalastyle.scalariform.OverrideJavaChecker",
        "name": "No use of Java @Override",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that while is not used.*\n\n`while` loops are deprecated if you're using a strict functional style.",
        "key": "org.scalastyle.scalariform.WhileChecker",
        "name": "No while loops",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*No whitespace after left bracket ''[''.*\n\nIf there is whitespace after a left bracket, this can be confusing to the reader.",
        "key": "org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker",
        "name": "No whitespace after left bracket ''[''",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*No whitespace before left bracket ''[''.*\n\nIf there is whitespace before a left bracket, this can be confusing to the reader.",
        "key": "org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker",
        "name": "No whitespace before left bracket ''[''",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*No whitespace before right bracket '']''.*\n\nIf there is whitespace before a right bracket, this can be confusing to the reader.",
        "key": "org.scalastyle.scalariform.NoWhitespaceBeforeRightBracketChecker",
        "name": "No whitespace before right bracket '']''",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Some editors are unfriendly to non ASCII characters.*\n\nScala allows unicode characters as operators and some editors misbehave when they see non-ascii character. In a project collaborated by a community of developers. This check can be helpful in such situations. \n\n```scala\n\"value\" match {\n  case \"value\" => println(\"matched\")\n  ...\n}\n```\n\nis preferred to\n\n```scala\n\"value\" match {\n  case \"value\" ⇒ println(\"matched\")\n  ...\n}\n```\n\nTo fix it, replace the (unicode operator) `⇒` with `=>`.",
        "key": "org.scalastyle.scalariform.NonASCIICharacterChecker",
        "name": "Non ASCII characters are not allowed",
        "params": [
          {
            "default": "false",
            "description": "Allow non-ASCII scripts in string literals.: White lists Unicode characters recognized by `\\p'{'Alnum'}'\\p'{'Punct'}'\\p'{'Sc'}'\\p'{'Space'}'` but not symbols like Emoji.",
            "name": "allowStringLiterals",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that null is not used.*\n\nScala discourages use of `null`, preferring `Option`.",
        "key": "org.scalastyle.scalariform.NullChecker",
        "name": "Null",
        "params": [
          {
            "default": "true",
            "description": "Allow null checks: Allow occurrences in checks like 'x == null' or 'x != null'.",
            "name": "allowNullChecks",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that a class / trait / object does not have too many methods.*\n\nIf a type declares too many methods, this can be an indication of bad design.",
        "key": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
        "name": "Number of methods in type",
        "params": [
          {
            "default": "30",
            "description": "Maximum methods: The maximum number of methods allowed.",
            "name": "maxMethods",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that there are not too many types declared in a file.*\n\nIf there are too many classes/objects defined in a single file, this can cause the code to be difficult to understand.",
        "key": "org.scalastyle.scalariform.NumberOfTypesChecker",
        "name": "Number of types",
        "params": [
          {
            "default": "20",
            "description": "Maximum Number: Maximum number of types to allow.",
            "name": "maxTypes",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that object names match a regular expression.*\n\nThe Scala style guide recommends that object names conform to certain standards.",
        "key": "org.scalastyle.scalariform.ObjectNamesChecker",
        "name": "Object name",
        "params": [
          {
            "default": "^[A-Z][A-Za-z]*$",
            "description": "Regular expression: The object names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that braces aren't used in case clauses.*\n\nBraces aren't required in case clauses. They should be omitted according to Scala Style Guide.",
        "key": "org.scalastyle.scalariform.CaseBraceChecker",
        "name": "Omit braces in case clauses",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that package names match a regular expression.*\n\nThe Scala style guide recommends that package names conform to certain standards.",
        "key": "org.scalastyle.scalariform.PackageNamesChecker",
        "name": "Package name",
        "params": [
          {
            "default": "^[a-z]+$",
            "description": "Regular expression: The package names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that package object names match a regular expression.*\n\nThe Scala style guide recommends that package object names conform to certain standards.",
        "key": "org.scalastyle.scalariform.PackageObjectNamesChecker",
        "name": "Package object name",
        "params": [
          {
            "default": "^[a-z][A-Za-z]*$",
            "description": "Regular expression: The package object names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that pattern match arrows align.*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.PatternMatchAlignChecker",
        "name": "Pattern match align",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that a method has an explicit return type, it is not inferred.*\n\nA public method declared on a type is effectively an API declaration. Explicitly declaring a return type means that other code which depends on that type won't break unexpectedly.",
        "key": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
        "name": "Public method must have type",
        "params": [
          {
            "default": "false",
            "description": "Ignore overridden methods: If true, public methods which override are ignored.",
            "name": "ignoreOverride",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*If a class/trait has no members, the braces are unnecessary.*\n\nIf a `class` / `trait` has no members, then braces are unnecessary, and can be removed.",
        "key": "org.scalastyle.scalariform.EmptyClassChecker",
        "name": "Redundant braces in class definition",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a regular expression cannot be matched, if found reports this.*\n\nSome checks can be carried out with a regular expression.",
        "key": "org.scalastyle.file.RegexChecker",
        "name": "Regular expression",
        "params": [
          {
            "default": "",
            "description": "Regular expression: Standard Scala regular expression syntax including multiline.",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Line: Boolean whether to process line by line.",
            "name": "line",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that a regular expression cannot be matched in a token, if found reports this.*\n\nSome checks can be carried by just the presence of a particular token.",
        "key": "org.scalastyle.scalariform.TokenChecker",
        "name": "Regular expression in a token",
        "params": [
          {
            "default": "^$",
            "description": "Regular expression: Standard Scala regular expression syntax.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that return is not used.*\n\nUse of `return` is not usually necessary in Scala. In fact, use of return can discourage a functional style of programming.",
        "key": "org.scalastyle.scalariform.ReturnChecker",
        "name": "Return",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Boolean expression can be simplified.*\n\nA boolean expression which can be simplified can make code easier to read.",
        "key": "org.scalastyle.scalariform.SimplifyBooleanExpressionChecker",
        "name": "Simplify Boolean expression",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that the plus sign is followed by a space.*\n\nAn expression with spaces around `+` can be easier to read.",
        "key": "org.scalastyle.scalariform.SpacesAfterPlusChecker",
        "name": "Space after plus",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks a space after the start of the comment.*\n\nTo bring consistency with how comments should be formatted, leave a space right after the beginning of the comment.\n\n```scala\npackage foobar\n\nobject Foobar {\n  /**WRONG\n    *\n    */\n  /** Correct\n    *\n    */\n  val d = 2 /*Wrong*/ //Wrong\n  /**\n    * Correct\n    */\n  val e = 3 /** Correct*/ // Correct\n}\n```",
        "key": "org.scalastyle.scalariform.SpaceAfterCommentStartChecker",
        "name": "Space after the start of the comment",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Disallow space after certain token(s).*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.DisallowSpaceAfterTokenChecker",
        "name": "Space after tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that the plus sign is preceded by a space.*\n\nAn expression with spaces around `+` can be easier to read.",
        "key": "org.scalastyle.scalariform.SpacesBeforePlusChecker",
        "name": "Space before plus",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Disallow space before certain token(s).*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.DisallowSpaceBeforeTokenChecker",
        "name": "Space before tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that structural types are not used.*\n\nStructural types in Scala can use reflection - this can have unexpected performance consequences. Warning: This check can also wrongly pick up type lamdbas and other such constructs. This checker should be used with care. You always have the alternative of the scalac checking for structural types.",
        "key": "org.scalastyle.scalariform.StructuralTypeChecker",
        "name": "Structural type",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check for use of TODO/FIXME single line comments.*\n\nSome projects may consider `TODO` or `FIXME` comments in a code bad style. They would rather you fix the problem.",
        "key": "org.scalastyle.scalariform.TodoCommentChecker",
        "name": "TODO/FIXME comment",
        "params": [
          {
            "default": "TODO|FIXME",
            "description": "Word list: Alternative list of words to look for, separated by |.",
            "name": "words",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that the code does not have ??? operators.*\n\nThe `???` operator denotes that an implementation is missing. This rule helps to avoid potential runtime errors because of not implemented code.",
        "key": "org.scalastyle.scalariform.NotImplementedErrorUsage",
        "name": "Usage of ??? operator",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Use a : Unit = for procedure declarations.*\n\nA procedure style declaration can cause confusion - the developer may have simply forgotten to add a `=`, and now their method returns `Unit` rather than the inferred type:\n\n```scala\ndef foo() { println(\"hello\"); 5 }\n```\nThis checker raises a warning with the first line. To fix it, use an explicit return type, or add a `=` before the body.\n\n```scala\ndef foo() = { println(\"hello\"); 5 }\n```",
        "key": "org.scalastyle.scalariform.ProcedureDeclarationChecker",
        "name": "Use : Unit = for procedures",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that braces are used in for comprehensions.*\n\nUsage of braces (rather than parentheses) within a `for` comprehension mean that you don't have to specify a semi-colon at the end of every line:\n\n```scala\nfor { // braces\n  t <- List(1,2,3)\n  if (t % 2 == 0)\n} yield t\n```\n\nis preferred to\n\n```scala\nfor ( // parentheses\n  t <- List(1,2,3);\n  if (t % 2 == 0)\n) yield t\n```\n\nTo fix it, replace the `()` with `{}`. And then remove the `;` at the end of the lines.\n\nThe `singleLineAllowed` property allows for constructions of the type:\n\n```scala\nfor (i <- List(1,2,3)) yield i\n```",
        "key": "org.scalastyle.scalariform.ForBraceChecker",
        "name": "Use braces in for comprehensions",
        "params": [
          {
            "default": "false",
            "description": "Allow parentheses for single-line for: For with parentheses allowed if everything is on one line.",
            "name": "singleLineAllowed",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that lines are indented by a multiple of the tab size.*\n\nCode that is not indented consistently can be hard to read.",
        "key": "org.scalastyle.file.IndentationChecker",
        "name": "Use correct indentation",
        "params": [
          {
            "default": "2",
            "description": "Tab size: Number of characters that a tab represents.",
            "name": "tabSize",
            "typ": "Integer"
          },
          {
            "default": "2",
            "description": "Multi-line method parameter spacing: Level of indentation of multi-line method parameters relative to the indentation of the first line of the method.",
            "name": "methodParamIndentSize",
            "typ": "Integer"
          },
          {
            "default": "4",
            "description": "Multi-line class parameter spacing: Level of indentation of multi-line primary constructor parameters of a class. Relative to the indentation of the first line of class declaration.",
            "name": "classParamIndentSize",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that parentheses are used in for loops.*\n\nFor-comprehensions which lack a `yield` clause is actually a loop rather than a functional comprehension and it is usually more readable to string the generators together between parentheses rather than using the syntactically-confusing `} {` construct:\n\n```scala\nfor (x <- board.rows; y <- board.files) {\n  printf(\"(%d, %d)\", x, y)\n}\n```\n\nis preferred to\n\n```scala\nfor {\n  x <- board.rows\n  y <- board.files\n} {\n  printf(\"(%d, %d)\", x, y)\n}\n```",
        "key": "org.scalastyle.scalariform.ForLoopChecker",
        "name": "Use parentheses in for loops",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that while body have braces.*\n\nWhile cannot be used in a pure-functional manner, that's why it's recommended to never omit braces according to Scala Style Guide.",
        "key": "org.scalastyle.scalariform.WhileBraceChecker",
        "name": "While body should have braces",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that there is no trailing whitespace at the end of lines.*\n\nWhitespace at the end of a line can cause problems when diffing between files or between versions.",
        "key": "org.scalastyle.file.WhitespaceEndOfLineChecker",
        "name": "Whitespace at end of line",
        "params": [
          {
            "default": "false",
            "description": "Ignore lines with just whitespace: Skip a line if the entire contents are whitespace characters.",
            "name": "ignoreWhitespaceLines",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that XML literals are not used.*\n\nSome projects prefer not to have XML literals. They could use a templating engine instead.",
        "key": "org.scalastyle.scalariform.XmlLiteralChecker",
        "name": "XML literals",
        "params": [],
        "severity": "Minor",
        "template": false
      }
    ],
    "scapegoat": [
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.NegationIsEmpty",
        "name": "!isEmpty can be replaced with nonEmpty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.NegationNonEmpty",
        "name": "!nonEmpty can be replaced with isEmpty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "Array equals is not an equality check. Use a.deep == b.deep or convert to another collection type",
        "key": "com.sksamuel.scapegoat.inspections.collections.ArrayEquals",
        "name": "Array equals",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.string.ArraysInFormat",
        "name": "Array passed to String.format",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.AvoidToMinusOne",
        "name": "Avoid To Minus One",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.AvoidSizeNotEqualsZero",
        "name": "Avoid Traversable.size != 0, use Traversable.nonEmpty instead",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.AvoidSizeEqualsZero",
        "name": "Avoid Traversable.size == 0, use Traversable.isEmpty instead",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.style.AvoidOperatorOverload",
        "name": "Avoid operator overload",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.math.BigDecimalDoubleConstructor",
        "name": "Big decimal double constructor",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "When using setScale() on a BigDecimal without setting the rounding mode, this can throw an exception if rounding is required. Did you mean to call setScale(s, RoundingMode.XYZ)",
        "key": "com.sksamuel.scapegoat.inspections.math.BigDecimalScaleWithoutRoundingMode",
        "name": "BigDecimal setScale() without rounding mode",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.inference.BoundedByFinalType",
        "name": "Bounded by final type",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.math.BrokenOddness",
        "name": "Broken odd check",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.exception.CatchException",
        "name": "Catch exception",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.exception.CatchFatal",
        "name": "Catch fatal exception",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.exception.CatchThrowable",
        "name": "Catch throwable",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.exception.CatchNpe",
        "name": "Catching NPE",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.naming.ClassNames",
        "name": "Class name not recommended",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.CollectionNegativeIndex",
        "name": "Collection index out of bounds",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.CollectionNamingConfusion",
        "name": "Collection naming Confusion",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.CollectionPromotionToAny",
        "name": "Collection promotion to any",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.equality.ComparingUnrelatedTypes",
        "name": "Comparing unrelated types",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "Comparision with self will always yield true",
        "key": "com.sksamuel.scapegoat.inspections.equality.ComparisonWithSelf",
        "name": "Comparision with self",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.ComparisonToEmptyList",
        "name": "Comparison to empty list",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.ComparisonToEmptySet",
        "name": "Comparison to empty set",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.ConstantIf",
        "name": "Constant if expression",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "Divide by one will always return the original value",
        "key": "com.sksamuel.scapegoat.inspections.math.DivideByOne",
        "name": "Divide by one",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.DoubleNegation",
        "name": "Double negation",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.imports.DuplicateImport",
        "name": "Duplicated Import",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.DuplicateMapKey",
        "name": "Duplicated map key",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.DuplicateSetValue",
        "name": "Duplicated set value",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "Empty case class can be rewritten as a case object",
        "key": "com.sksamuel.scapegoat.inspections.EmptyCaseClass",
        "name": "Empty case class",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.exception.SwallowedException",
        "name": "Empty catch block",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyFor",
        "name": "Empty for loop",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyIfBlock",
        "name": "Empty if statement",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.string.EmptyInterpolatedString",
        "name": "Empty interpolated string",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyMethod",
        "name": "Empty method",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptySynchronizedBlock",
        "name": "Empty synchronized block",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyTryBlock",
        "name": "Empty try block",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyWhileBlock",
        "name": "Empty while block",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.ExistsSimplifiableToContains",
        "name": "Exists simplifiable to contains",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "Finalizers should call super.finalize() to ensure superclasses are able to run any finalization logic",
        "key": "com.sksamuel.scapegoat.inspections.unsafe.FinalizerWithoutSuper",
        "name": "Finalizer without super",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.equality.ComparingFloatingPointTypes",
        "name": "Floating type comparison",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.string.IllegalFormatString",
        "name": "Illegal format string",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.option.ImpossibleOptionSizeCondition",
        "name": "Impossible Option.size condition",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.string.IncorrectNumberOfArgsToFormat",
        "name": "Incorrect number of args for format",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.exception.IncorrectlyNamedExceptions",
        "name": "Incorrectly Named Exceptions",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.math.ModOne",
        "name": "Integer mod one",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.string.InvalidRegex",
        "name": "Invalid regex",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "Use of java conversions can lead to unusual behaviour. It is recommended to use JavaConverters",
        "key": "com.sksamuel.scapegoat.inspections.collections.JavaConversionsUse",
        "name": "Java conversions",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "List append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer or Vector and converting to a List once built.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ListAppend",
        "name": "List append is slow",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "List.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or Array.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ListSize",
        "name": "List.size is O(n)",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.LonelySealedTrait",
        "name": "Lonely sealed trait",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.string.LooksLikeInterpolatedString",
        "name": "Looks Like Interpolated String",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.matching.PartialFunctionInsteadOfMatch",
        "name": "Match instead of partial function",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.MaxParameters",
        "name": "Max parameters",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.inference.MethodReturningAny",
        "name": "Method Returning Any",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "Methods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods",
        "key": "com.sksamuel.scapegoat.inspections.naming.MethodNames",
        "name": "Method name not recommended",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "Case classes should have final modifier",
        "key": "com.sksamuel.scapegoat.inspections.FinalModifierOnCaseClass",
        "name": "Missing final modifier on case class",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "NaN comparision will always fail. Use value.isNan instead.",
        "key": "com.sksamuel.scapegoat.inspections.math.NanComparison",
        "name": "Nan comparision",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.NoOpOverride",
        "name": "No op Override",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.nulls.NullAssignment",
        "name": "Null assignment",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.nulls.NullParameter",
        "name": "Null parameter",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.naming.ObjectNames",
        "name": "Object name not recommended",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.style.ParameterlessMethodReturnsUnit",
        "name": "Parameterless methods returns unit",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.inference.PointlessTypeBounds",
        "name": "Pointless Type Bounds",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.PreferMapEmpty",
        "name": "Prefer Map.empty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.option.OptionSize",
        "name": "Prefer Option.isDefined instead of Option.size",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.PreferSeqEmpty",
        "name": "Prefer Seq.empty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.PreferSetEmpty",
        "name": "Prefer Set.empty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.inference.ProductWithSerializableInferred",
        "name": "Product with Serializable inferred",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "Public finalizer should be avoided as finalizers should not be programatically invoked",
        "key": "com.sksamuel.scapegoat.inspections.PublicFinalizer",
        "name": "PublicFinalizer",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.RedundantFinalModifierOnMethod",
        "name": "Redundant final modifier on method",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "This var cannot be overridden, final modifier is redundant",
        "key": "com.sksamuel.scapegoat.inspections.RedundantFinalModifierOnVar",
        "name": "Redundant final modifier on var",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.RedundantFinalizer",
        "name": "Redundant finalizer",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.matching.RepeatedCaseBody",
        "name": "Repeated case body",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.CollectionIndexOnNonIndexedSeq",
        "name": "Seq.apply() on a non-IndexedSeq may cause performance problems",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.style.SimplifyBooleanExpression",
        "name": "Simplify boolean expressions",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.string.SubstringZero",
        "name": "String.substring(0)",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "Strip margin will strip | from regex - possible corrupted regex",
        "key": "com.sksamuel.scapegoat.inspections.string.StripMarginOnRegex",
        "name": "Strip margin on regex",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.matching.SuspiciousMatchOnClassObject",
        "name": "Suspicious match on class object",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.SwapSortFilter",
        "name": "Swap sort filter",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.TypeShadowing",
        "name": "Type shadowing",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryConversion",
        "name": "Unnecessary conversion",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryIf",
        "name": "Unnecessary if condition.",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "Scala returns the value of the last expression in a block. Use of return here is not idiomatic scala",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryReturnUse",
        "name": "Unnecessary return",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.ReverseFunc",
        "name": "Unnecessary reverse",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.exception.UnreachableCatch",
        "name": "Unreachable catch",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.UnsafeContains",
        "name": "Unsafe contains",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.string.UnsafeStringContains",
        "name": "Unsafe string contains",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnusedMethodParameter",
        "name": "Unused parameter",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.math.UseCbrt",
        "name": "Use cbrt",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.math.UseExpM1",
        "name": "Use expm1",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.math.UseLog10",
        "name": "Use log10",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.math.UseLog1P",
        "name": "Use log1p",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.MapGetAndGetOrElse",
        "name": "Use of .get.getOrElse instead of .getOrElse",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.string.ArraysToString",
        "name": "Use of Array.toString",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.option.EitherGet",
        "name": "Use of Either Right or Left Projection get",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.option.OptionGet",
        "name": "Use of Option.get",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.unsafe.TryGet",
        "name": "Use of Try.get",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.unsafe.AsInstanceOf",
        "name": "Use of asInstanceOf",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.unsafe.IsInstanceOf",
        "name": "Use of isInstanceOf",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.UnsafeTraversableMethods",
        "name": "Use of unsafe Traversable methods (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy)",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.math.UseSqrt",
        "name": "Use sqrt",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.VarCouldBeVal",
        "name": "Var could be val",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.VarClosure",
        "name": "Var in closure",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.controlflow.WhileTrue",
        "name": "While true loop",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "Dividing zero by any number will always return zero",
        "key": "com.sksamuel.scapegoat.inspections.math.ZeroNumerator",
        "name": "Zero numerator",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotHead",
        "name": "filter().head can throw an exception; use find()",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotHeadOption",
        "name": "filter().headOption instead of find()",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotIsEmpty",
        "name": "filter().isEmpty instead of !exists()",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotSize",
        "name": "filter().size() instead of count()",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterOptionAndGet",
        "name": "filter(_.isDefined).map(_.get) instead of flatten",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.FindAndNotEqualsNoneReplaceWithExists",
        "name": "find(x => ) != None instead of exists(x =>)",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.ReverseTailReverse",
        "name": "reverse.tail.reverse instead of init",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.ReverseTakeReverse",
        "name": "reverse.take(...).reverse instead of takeRight",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "",
        "key": "com.sksamuel.scapegoat.inspections.collections.FindDotIsDefined",
        "name": "use exists() not find().isDefined()",
        "params": [],
        "severity": "Info",
        "template": false
      }
    ]
  }
}