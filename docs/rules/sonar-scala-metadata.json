{
  "repositories": {
    "sonar-scala-scalastyle": {
      "key": "sonar-scala-scalastyle",
      "name": "Scalastyle",
      "rules": [
        {
          "description": "*Checks that block imports are not used.*\n\nBlock imports, e.g. `import a.{b, c}` can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports are used in order to minimize merge errors in import declarations.",
          "key": "org.scalastyle.scalariform.BlockImportChecker",
          "name": "Avoid block imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.BlockImportChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that curlies imports are not used.*\n\nCurlies imports, e.g. `import a.{b, c}`, can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports, no renaming and no hiding imports are used in order to minimize merge errors in import declarations.",
          "key": "org.scalastyle.scalariform.CurliesImportChecker",
          "name": "Avoid curlies imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.CurliesImportChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Avoid wildcard imports.*\n\nImporting all classes from a package or static members from a class leads to tight coupling between packages or classes and might lead to problems when a new version of a library introduces name clashes.",
          "key": "org.scalastyle.scalariform.UnderscoreImportChecker",
          "name": "Avoid wildcard imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.UnderscoreImportChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that class names match a regular expression.*\n\nThe Scala style guide recommends that class names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ClassNamesChecker-template",
          "name": "Class name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The class names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that class names match a regular expression.*\n\nThe Scala style guide recommends that class names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ClassNamesChecker",
          "name": "Class name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The class names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that type parameter to a class matches a regular expression.*\n\nScala generic type names are generally single upper case letters. This check checks for classes and traits. Note that this check only checks the innermost type parameter, to allow for `List[T]`.",
          "key": "org.scalastyle.scalariform.ClassTypeParameterChecker-template",
          "name": "Class type parameter name",
          "params": [
            {
              "default": "^[A-Z_]$",
              "description": "Regular expression: Standard Scala regular expression syntax.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassTypeParameterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that type parameter to a class matches a regular expression.*\n\nScala generic type names are generally single upper case letters. This check checks for classes and traits. Note that this check only checks the innermost type parameter, to allow for `List[T]`.",
          "key": "org.scalastyle.scalariform.ClassTypeParameterChecker",
          "name": "Class type parameter name",
          "params": [
            {
              "default": "^[A-Z_]$",
              "description": "Regular expression: Standard Scala regular expression syntax.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ClassTypeParameterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that classes and objects do not define the clone() method.*\n\nThe clone method is difficult to get right. You can use the copy constructor of case classes rather than implementing clone. For more information on `clone()`, see Effective Java by Joshua Bloch pages.",
          "key": "org.scalastyle.scalariform.NoCloneChecker",
          "name": "Clone method",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoCloneChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that classes and objects do not define equals without overriding equals(java.lang.Object).*\n\nMistakenly defining a covariant `equals()` method without overriding method `equals(java.lang.Object)` can produce unexpected runtime behaviour.",
          "key": "org.scalastyle.scalariform.CovariantEqualsChecker",
          "name": "Covariant equals",
          "params": [
            {
              "default": "org.scalastyle.scalariform.CovariantEqualsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that the cyclomatic complexity of a method does exceed a value.*\n\nIf the code is too complex, then this can make code hard to read.",
          "key": "org.scalastyle.scalariform.CyclomaticComplexityChecker-template",
          "name": "Cyclomatic complexity",
          "params": [
            {
              "default": "10",
              "description": "Maximum: Maximum cyclomatic complexity to allow for a method.",
              "name": "maximum",
              "typ": "Integer"
            },
            {
              "default": "true",
              "description": "Count Cases: If true, each case increases method complexity, else only match keyword is considered.",
              "name": "countCases",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that the cyclomatic complexity of a method does exceed a value.*\n\nIf the code is too complex, then this can make code hard to read.",
          "key": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
          "name": "Cyclomatic complexity",
          "params": [
            {
              "default": "10",
              "description": "Maximum: Maximum cyclomatic complexity to allow for a method.",
              "name": "maximum",
              "typ": "Integer"
            },
            {
              "default": "true",
              "description": "Count Cases: If true, each case increases method complexity, else only match keyword is considered.",
              "name": "countCases",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*The interpolation for this string literal is not necessary.*\n\nEmpty interpolated strings are harder to read and not necessary.",
          "key": "org.scalastyle.scalariform.EmptyInterpolatedStringChecker",
          "name": "Empty interpolated string",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EmptyInterpolatedStringChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that if a class implements either equals or hashCode, it should implement the other.*\n\nDefining either equals or hashCode in a class without defining the is a known source of bugs. Usually, when you define one, you should also define the other.",
          "key": "org.scalastyle.scalariform.EqualsHashCodeChecker",
          "name": "Equals hashCode",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EqualsHashCodeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that field names match a regular expression.*\n\nA consistent naming convention for field names can make code easier to read and understand.",
          "key": "org.scalastyle.scalariform.FieldNamesChecker-template",
          "name": "Field name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The field names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^[A-Z][A-Za-z0-9]*$",
              "description": "Regular expression for constants: The object field (constant) names must match this regular expression.",
              "name": "objectFieldRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.FieldNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that field names match a regular expression.*\n\nA consistent naming convention for field names can make code easier to read and understand.",
          "key": "org.scalastyle.scalariform.FieldNamesChecker",
          "name": "Field name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The field names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^[A-Z][A-Za-z0-9]*$",
              "description": "Regular expression for constants: The object field (constant) names must match this regular expression.",
              "name": "objectFieldRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.FieldNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check the number of lines in a file.*\n\nFiles which are too long can be hard to read and understand.",
          "key": "org.scalastyle.file.FileLengthChecker-template",
          "name": "File length",
          "params": [
            {
              "default": "1500",
              "description": "Maximum file length: Maximum number of lines in a file.",
              "name": "maxFileLength",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.file.FileLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check the number of lines in a file.*\n\nFiles which are too long can be hard to read and understand.",
          "key": "org.scalastyle.file.FileLengthChecker",
          "name": "File length",
          "params": [
            {
              "default": "1500",
              "description": "Maximum file length: Maximum number of lines in a file.",
              "name": "maxFileLength",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.file.FileLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check the number of characters in a line.*\n\nLines that are too long can be hard to read and horizontal scrolling is annoying.",
          "key": "org.scalastyle.file.FileLineLengthChecker-template",
          "name": "File line length",
          "params": [
            {
              "default": "160",
              "description": "Maximum line length: Maximum number of characters in a line.",
              "name": "maxLineLength",
              "typ": "Integer"
            },
            {
              "default": "4",
              "description": "Tab size: Number of characters that a tab represents.",
              "name": "tabSize",
              "typ": "Integer"
            },
            {
              "default": "false",
              "description": "Ignore import statements: Ignore import statements.",
              "name": "ignoreImports",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.FileLineLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check the number of characters in a line.*\n\nLines that are too long can be hard to read and horizontal scrolling is annoying.",
          "key": "org.scalastyle.file.FileLineLengthChecker",
          "name": "File line length",
          "params": [
            {
              "default": "160",
              "description": "Maximum line length: Maximum number of characters in a line.",
              "name": "maxLineLength",
              "typ": "Integer"
            },
            {
              "default": "4",
              "description": "Tab size: Number of characters that a tab represents.",
              "name": "tabSize",
              "typ": "Integer"
            },
            {
              "default": "false",
              "description": "Ignore import statements: Ignore import statements.",
              "name": "ignoreImports",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.FileLineLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that classes and objects do not define the finalize() method.*\n\n`finalize()` is called when the object is garbage collected, and garbage collection is not guaranteed to happen. It is therefore unwise to rely on code in `finalize()` method.",
          "key": "org.scalastyle.scalariform.NoFinalizeChecker",
          "name": "Finalize method",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoFinalizeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that imports are grouped together, not throughout the file.*\n\nIf imports are spread throughout the file, knowing what is in scope at any one place can be difficult to work out.",
          "key": "org.scalastyle.scalariform.ImportGroupingChecker",
          "name": "Group imports",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ImportGroupingChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that if statements have braces.*\n\nSome people find if clauses with braces easier to read.\n\nThe `singleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nThe `doubleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nNote: If you intend to enable only if expressions in the format below, disable the IfBraceChecker altogether.\n\n```scala\nif (bool_expression) expression1 else expression2\n```",
          "key": "org.scalastyle.scalariform.IfBraceChecker-template",
          "name": "If block braces",
          "params": [
            {
              "default": "true",
              "description": "Single Line Allowed: If without braces allowed if everything is on one line.",
              "name": "singleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "false",
              "description": "Double Line Allowed: If without braces allowed if everything is on one line or two lines.",
              "name": "doubleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.IfBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that if statements have braces.*\n\nSome people find if clauses with braces easier to read.\n\nThe `singleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nThe `doubleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nNote: If you intend to enable only if expressions in the format below, disable the IfBraceChecker altogether.\n\n```scala\nif (bool_expression) expression1 else expression2\n```",
          "key": "org.scalastyle.scalariform.IfBraceChecker",
          "name": "If block braces",
          "params": [
            {
              "default": "true",
              "description": "Single Line Allowed: If without braces allowed if everything is on one line.",
              "name": "singleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "false",
              "description": "Double Line Allowed: If without braces allowed if everything is on one line or two lines.",
              "name": "doubleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.IfBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that a class does not import certain classes.*\n\nUse of some classes can be discouraged for a project. For instance, use of `sun._` is generally discouraged because they are internal to the JDK and can be changed.",
          "key": "org.scalastyle.scalariform.IllegalImportsChecker-template",
          "name": "Illegal imports",
          "params": [
            {
              "default": "sun._,java.awt._",
              "description": "Illegal Imports: The comma separated list of illegal imports, wildcards allowed.",
              "name": "illegalImports",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.IllegalImportsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that a class does not import certain classes.*\n\nUse of some classes can be discouraged for a project. For instance, use of `sun._` is generally discouraged because they are internal to the JDK and can be changed.",
          "key": "org.scalastyle.scalariform.IllegalImportsChecker",
          "name": "Illegal imports",
          "params": [
            {
              "default": "sun._,java.awt._",
              "description": "Illegal Imports: The comma separated list of illegal imports, wildcards allowed.",
              "name": "illegalImports",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.IllegalImportsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that imports are grouped and ordered according to the style configuration.*\n\nConsistent import ordering improves code readability and reduces unrelated changes in patches.",
          "key": "org.scalastyle.scalariform.ImportOrderChecker",
          "name": "Import Order",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ImportOrderChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that there are no tabs in a file.*\n\nSome say that tabs are evil.",
          "key": "org.scalastyle.file.FileTabChecker",
          "name": "Line contains Tab",
          "params": [
            {
              "default": "org.scalastyle.file.FileTabChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that argument literals are named.*\n\nNameless literals make code harder to understand (consider `updateEntity(1, true)` and `updateEntity(id = 1, enabled = true)`).",
          "key": "org.scalastyle.scalariform.NamedArgumentChecker-template",
          "name": "Literal passed as argument without name",
          "params": [
            {
              "default": "false",
              "description": "Check string literals: If true, also checks that string literal arguments are named.",
              "name": "checkString",
              "typ": "Boolean"
            },
            {
              "default": "^set.+$",
              "description": "Ignore methods by pattern: Pattern to ignore method calls by name.",
              "name": "ignoreMethod",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.NamedArgumentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that argument literals are named.*\n\nNameless literals make code harder to understand (consider `updateEntity(1, true)` and `updateEntity(id = 1, enabled = true)`).",
          "key": "org.scalastyle.scalariform.NamedArgumentChecker",
          "name": "Literal passed as argument without name",
          "params": [
            {
              "default": "false",
              "description": "Check string literals: If true, also checks that string literal arguments are named.",
              "name": "checkString",
              "typ": "Boolean"
            },
            {
              "default": "^set.+$",
              "description": "Ignore methods by pattern: Pattern to ignore method calls by name.",
              "name": "ignoreMethod",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.NamedArgumentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that if a long literal is used, then an uppercase L is used.*\n\nA lowercase L (l) can look similar to a number 1 with some fonts.",
          "key": "org.scalastyle.scalariform.UppercaseLChecker",
          "name": "Long literal uppercase L",
          "params": [
            {
              "default": "org.scalastyle.scalariform.UppercaseLChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a case statement pattern match is not lower case, as this can cause confusion.*\n\nA lower case pattern match clause with no other tokens is the same as `_`; this is not true for patterns which start with an upper case letter. This can cause confusion, and may not be what was intended:\n\n```scala\nval foo = \"foo\"\nval Bar = \"bar\"\n\"bar\" match { case Bar => \"we got bar\" } // result = \"we got bar\"\n\"bar\" match { case foo => \"we got foo\" } // result = \"we got foo\"\n\"bar\" match { case `foo` => \"we got foo\" } // result = MatchError\n```\n\nThis checker raises a warning with the second match. To fix it, use an identifier which starts with an upper case letter (best), use `case _` or, if you wish to refer to the value, add a type `: Any`, e.g.:\n\n```scala\nval lc = \"lc\"\n\"something\" match { case lc: Any => \"lc\" } // result = \"lc\"\n\"something\" match { case _ => \"lc\" } // result = \"lc\"\n```",
          "key": "org.scalastyle.scalariform.LowercasePatternMatchChecker",
          "name": "Lowercase pattern match",
          "params": [
            {
              "default": "org.scalastyle.scalariform.LowercasePatternMatchChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of magic numbers.*\n\nReplacing a magic number with a named constant can make code easier to read and understand, and can avoid some subtle bugs.\n\nA simple assignment to a val is not considered to be a magic number, for example: `val foo = 4` is not a magic number, but `var foo = 4` is considered to be a magic number.",
          "key": "org.scalastyle.scalariform.MagicNumberChecker-template",
          "name": "Magic Number",
          "params": [
            {
              "default": "-1,0,1,2",
              "description": "Ignore: The comma separated list of numbers to ignore when used as magic numbers.",
              "name": "ignore",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MagicNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks for use of magic numbers.*\n\nReplacing a magic number with a named constant can make code easier to read and understand, and can avoid some subtle bugs.\n\nA simple assignment to a val is not considered to be a magic number, for example: `val foo = 4` is not a magic number, but `var foo = 4` is considered to be a magic number.",
          "key": "org.scalastyle.scalariform.MagicNumberChecker",
          "name": "Magic Number",
          "params": [
            {
              "default": "-1,0,1,2",
              "description": "Ignore: The comma separated list of numbers to ignore when used as magic numbers.",
              "name": "ignore",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MagicNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check the first lines of each file matches the text.*\n\nA lot of projects require a header with a copyright notice, or they require a license in each file. This does a simple text comparison between the header and the first lines of the file. You can have multiple lines, but make sure you surround the text with a `CDATA` section. You can also specify a regular expression, as long as you set the regex parameter to `true`.",
          "key": "org.scalastyle.file.HeaderMatchesChecker-template",
          "name": "Match Header",
          "params": [
            {
              "default": "",
              "description": "Header: The lines to compare against.",
              "name": "header",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Header Regex: Whether to treat the header string as a regular expression.",
              "name": "regex",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.HeaderMatchesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Maximum number of parameters for a method.*\n\nA method which has more than a certain number of parameters can be hard to understand.",
          "key": "org.scalastyle.scalariform.ParameterNumberChecker-template",
          "name": "Maximum parameters",
          "params": [
            {
              "default": "8",
              "description": "Maximum Number: The maximum number of parameters.",
              "name": "maxParameters",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.ParameterNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Maximum number of parameters for a method.*\n\nA method which has more than a certain number of parameters can be hard to understand.",
          "key": "org.scalastyle.scalariform.ParameterNumberChecker",
          "name": "Maximum parameters",
          "params": [
            {
              "default": "8",
              "description": "Maximum Number: The maximum number of parameters.",
              "name": "maxParameters",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.ParameterNumberChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that method argument names match a regular expression.*\n\nThe Scala style guide recommends that method argument names conform to certain standards.",
          "key": "org.scalastyle.scalariform.MethodArgumentNamesChecker-template",
          "name": "Method argument name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The method argument names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method argument names which match this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that method argument names match a regular expression.*\n\nThe Scala style guide recommends that method argument names conform to certain standards.",
          "key": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
          "name": "Method argument name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*$",
              "description": "Regular expression: The method argument names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method argument names which match this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that methods do not exceed a maximum length.*\n\nLong methods can be hard to read and understand.",
          "key": "org.scalastyle.scalariform.MethodLengthChecker-template",
          "name": "Method length",
          "params": [
            {
              "default": "50",
              "description": "Maximum length: Maximum number of lines allowed for a method.",
              "name": "maxLength",
              "typ": "Integer"
            },
            {
              "default": "false",
              "description": "Ignore comments: If set to true, comment lines in method body won't be counted.",
              "name": "ignoreComments",
              "typ": "Boolean"
            },
            {
              "default": "false",
              "description": "Ignore empty lines: If set to true, empty lines in method body won't be counted.",
              "name": "ignoreEmpty",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.MethodLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that methods do not exceed a maximum length.*\n\nLong methods can be hard to read and understand.",
          "key": "org.scalastyle.scalariform.MethodLengthChecker",
          "name": "Method length",
          "params": [
            {
              "default": "50",
              "description": "Maximum length: Maximum number of lines allowed for a method.",
              "name": "maxLength",
              "typ": "Integer"
            },
            {
              "default": "false",
              "description": "Ignore comments: If set to true, comment lines in method body won't be counted.",
              "name": "ignoreComments",
              "typ": "Boolean"
            },
            {
              "default": "false",
              "description": "Ignore empty lines: If set to true, empty lines in method body won't be counted.",
              "name": "ignoreEmpty",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.MethodLengthChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that method names match a regular expression.*\n\nThe Scala style guide recommends that method names conform to certain standards. If the methods are overriding another method, and the overridden method cannot be changed, then use the `ignoreOverride` parameter.",
          "key": "org.scalastyle.scalariform.MethodNamesChecker-template",
          "name": "Method name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*(_=)?$",
              "description": "Regular expression: The method names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method names which match this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.MethodNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that method names match a regular expression.*\n\nThe Scala style guide recommends that method names conform to certain standards. If the methods are overriding another method, and the overridden method cannot be changed, then use the `ignoreOverride` parameter.",
          "key": "org.scalastyle.scalariform.MethodNamesChecker",
          "name": "Method name",
          "params": [
            {
              "default": "^[a-z][A-Za-z0-9]*(_=)?$",
              "description": "Regular expression: The method names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Regular expression to ignore: Method names which match this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.MethodNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that the ScalaDoc on documentable members is well-formed.*\n\nScaladoc is generally considered a good thing. Within reason.\n\nIgnore tokens is a comma separated string that may include the following: `PatDefOrDcl` (variables), `TmplDef` (classes, traits), `TypeDefOrDcl` (type definitions), `FunDefOrDcl` (functions). Supported indentation styles are \"scaladoc\" (for ScalaDoc-style comments, with two spaces before the asterisk), \"javadoc\" (for JavaDoc-style comments, with a single space before the asterisk) or \"anydoc\" to support any style (any number of spaces before the asterisk). For backwards compatibility, if left empty, \"anydoc\" will be assumed.",
          "key": "org.scalastyle.scalariform.ScalaDocChecker-template",
          "name": "Missing or badly formed ScalaDoc",
          "params": [
            {
              "default": "^$",
              "description": "Regular expression: Class names matching this regular expression will be ignored.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "^$",
              "description": "Comma Separated String: Include the following to ignore : PatDefOrDcl (variables), TmplDef (classes, traits), TypeDefOrDcl (type definitions), FunDefOrDcl (functions).",
              "name": "ignoreTokenTypes",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "anydoc",
              "description": "Force indent style: Possible values: scaladoc - 2 spaces before *, javadoc - 1 space before *.",
              "name": "indentStyle",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ScalaDocChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a string literal does not appear multiple times.*\n\nCode duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.",
          "key": "org.scalastyle.scalariform.MultipleStringLiteralsChecker-template",
          "name": "Multiple string literals",
          "params": [
            {
              "default": "1",
              "description": "Maximum occurences allowed: Maximum number of occurences allowed.",
              "name": "allowed",
              "typ": "Integer"
            },
            {
              "default": "^\"\"$",
              "description": "Ignore regular expression: Regular expression to ignore.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a string literal does not appear multiple times.*\n\nCode duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.",
          "key": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
          "name": "Multiple string literals",
          "params": [
            {
              "default": "1",
              "description": "Maximum occurences allowed: Maximum number of occurences allowed.",
              "name": "allowed",
              "typ": "Integer"
            },
            {
              "default": "^\"\"$",
              "description": "Ignore regular expression: Regular expression to ignore.",
              "name": "ignoreRegex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a file ends with a newline character.*\n\nSome version control systems don't cope well with files which don't end with a newline character.",
          "key": "org.scalastyle.file.NewLineAtEofChecker",
          "name": "Newline at EOF",
          "params": [
            {
              "default": "org.scalastyle.file.NewLineAtEofChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a file does not end with a newline character.*\n\nBecause Mirco Dotta wanted it.",
          "key": "org.scalastyle.file.NoNewLineAtEofChecker",
          "name": "No Newline at EOF",
          "params": [
            {
              "default": "org.scalastyle.file.NoNewLineAtEofChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that classes and objects do not define mutable fields.*\n\n`var` (mutable fields) are deprecated if you're using a strict functional style.",
          "key": "org.scalastyle.scalariform.VarFieldChecker",
          "name": "No mutable fields",
          "params": [
            {
              "default": "org.scalastyle.scalariform.VarFieldChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that functions do not define mutable variables.*\n\n`var` (mutable local variables) are deprecated if you're using a strict functional style.",
          "key": "org.scalastyle.scalariform.VarLocalChecker",
          "name": "No mutable local variables",
          "params": [
            {
              "default": "org.scalastyle.scalariform.VarLocalChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that if expressions are not redundant, i.e. easily replaced by a variant of the condition.*\n\nIf expressions with boolean constants in both branches can be eliminated without affecting readability. Prefer simply `cond` to `if (cond) true else false` and `!cond` to `if (cond) false else true`.",
          "key": "org.scalastyle.scalariform.RedundantIfChecker",
          "name": "No redundant if expressions",
          "params": [
            {
              "default": "org.scalastyle.scalariform.RedundantIfChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Ensure single space after certain token(s).*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.EnsureSingleSpaceAfterTokenChecker",
          "name": "No space after tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EnsureSingleSpaceAfterTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Ensure single space before certain token(s).*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker",
          "name": "No space before tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that throw is not used.*\n\n`throw` statements should be replaced with type-safe error constructs like `Try` and `Either`, which communicate the possibility of error in the type signature.",
          "key": "org.scalastyle.scalariform.ThrowChecker",
          "name": "No throw statements.",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ThrowChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that Java @Deprecated is not used, Scala @deprecated should be used instead.*\n\nYou should be using the Scala `@deprecated` instead.",
          "key": "org.scalastyle.scalariform.DeprecatedJavaChecker",
          "name": "No use of Java @Deprecated",
          "params": [
            {
              "default": "org.scalastyle.scalariform.DeprecatedJavaChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that Java @Override is not used.*\n\nYou should be using the Scala override keyword instead.",
          "key": "org.scalastyle.scalariform.OverrideJavaChecker",
          "name": "No use of Java @Override",
          "params": [
            {
              "default": "org.scalastyle.scalariform.OverrideJavaChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that while is not used.*\n\n`while` loops are deprecated if you're using a strict functional style.",
          "key": "org.scalastyle.scalariform.WhileChecker",
          "name": "No while loops",
          "params": [
            {
              "default": "org.scalastyle.scalariform.WhileChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*No whitespace after left bracket ''[''.*\n\nIf there is whitespace after a left bracket, this can be confusing to the reader.",
          "key": "org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker",
          "name": "No whitespace after left bracket ''[''",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*No whitespace before left bracket ''[''.*\n\nIf there is whitespace before a left bracket, this can be confusing to the reader.",
          "key": "org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker",
          "name": "No whitespace before left bracket ''[''",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*No whitespace before right bracket '']''.*\n\nIf there is whitespace before a right bracket, this can be confusing to the reader.",
          "key": "org.scalastyle.scalariform.NoWhitespaceBeforeRightBracketChecker",
          "name": "No whitespace before right bracket '']''",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NoWhitespaceBeforeRightBracketChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Some editors are unfriendly to non ASCII characters.*\n\nScala allows unicode characters as operators and some editors misbehave when they see non-ascii character. In a project collaborated by a community of developers. This check can be helpful in such situations. \n\n```scala\n\"value\" match {\n  case \"value\" => println(\"matched\")\n  ...\n}\n```\n\nis preferred to\n\n```scala\n\"value\" match {\n  case \"value\" ⇒ println(\"matched\")\n  ...\n}\n```\n\nTo fix it, replace the (unicode operator) `⇒` with `=>`.",
          "key": "org.scalastyle.scalariform.NonASCIICharacterChecker-template",
          "name": "Non ASCII characters are not allowed",
          "params": [
            {
              "default": "false",
              "description": "Allow non-ASCII scripts in string literals.: White lists Unicode characters recognized by `\\p'{'Alnum'}'\\p'{'Punct'}'\\p'{'Sc'}'\\p'{'Space'}'` but not symbols like Emoji.",
              "name": "allowStringLiterals",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.NonASCIICharacterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Some editors are unfriendly to non ASCII characters.*\n\nScala allows unicode characters as operators and some editors misbehave when they see non-ascii character. In a project collaborated by a community of developers. This check can be helpful in such situations. \n\n```scala\n\"value\" match {\n  case \"value\" => println(\"matched\")\n  ...\n}\n```\n\nis preferred to\n\n```scala\n\"value\" match {\n  case \"value\" ⇒ println(\"matched\")\n  ...\n}\n```\n\nTo fix it, replace the (unicode operator) `⇒` with `=>`.",
          "key": "org.scalastyle.scalariform.NonASCIICharacterChecker",
          "name": "Non ASCII characters are not allowed",
          "params": [
            {
              "default": "false",
              "description": "Allow non-ASCII scripts in string literals.: White lists Unicode characters recognized by `\\p'{'Alnum'}'\\p'{'Punct'}'\\p'{'Sc'}'\\p'{'Space'}'` but not symbols like Emoji.",
              "name": "allowStringLiterals",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.NonASCIICharacterChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that null is not used.*\n\nScala discourages use of `null`, preferring `Option`.",
          "key": "org.scalastyle.scalariform.NullChecker-template",
          "name": "Null",
          "params": [
            {
              "default": "true",
              "description": "Allow null checks: Allow occurrences in checks like 'x == null' or 'x != null'.",
              "name": "allowNullChecks",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.NullChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that null is not used.*\n\nScala discourages use of `null`, preferring `Option`.",
          "key": "org.scalastyle.scalariform.NullChecker",
          "name": "Null",
          "params": [
            {
              "default": "true",
              "description": "Allow null checks: Allow occurrences in checks like 'x == null' or 'x != null'.",
              "name": "allowNullChecks",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.NullChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that a class / trait / object does not have too many methods.*\n\nIf a type declares too many methods, this can be an indication of bad design.",
          "key": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker-template",
          "name": "Number of methods in type",
          "params": [
            {
              "default": "30",
              "description": "Maximum methods: The maximum number of methods allowed.",
              "name": "maxMethods",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that a class / trait / object does not have too many methods.*\n\nIf a type declares too many methods, this can be an indication of bad design.",
          "key": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
          "name": "Number of methods in type",
          "params": [
            {
              "default": "30",
              "description": "Maximum methods: The maximum number of methods allowed.",
              "name": "maxMethods",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that there are not too many types declared in a file.*\n\nIf there are too many classes/objects defined in a single file, this can cause the code to be difficult to understand.",
          "key": "org.scalastyle.scalariform.NumberOfTypesChecker-template",
          "name": "Number of types",
          "params": [
            {
              "default": "20",
              "description": "Maximum Number: Maximum number of types to allow.",
              "name": "maxTypes",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfTypesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that there are not too many types declared in a file.*\n\nIf there are too many classes/objects defined in a single file, this can cause the code to be difficult to understand.",
          "key": "org.scalastyle.scalariform.NumberOfTypesChecker",
          "name": "Number of types",
          "params": [
            {
              "default": "20",
              "description": "Maximum Number: Maximum number of types to allow.",
              "name": "maxTypes",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.scalariform.NumberOfTypesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that object names match a regular expression.*\n\nThe Scala style guide recommends that object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ObjectNamesChecker-template",
          "name": "Object name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The object names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that object names match a regular expression.*\n\nThe Scala style guide recommends that object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.ObjectNamesChecker",
          "name": "Object name",
          "params": [
            {
              "default": "^[A-Z][A-Za-z]*$",
              "description": "Regular expression: The object names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.ObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that braces aren't used in case clauses.*\n\nBraces aren't required in case clauses. They should be omitted according to Scala Style Guide.",
          "key": "org.scalastyle.scalariform.CaseBraceChecker",
          "name": "Omit braces in case clauses",
          "params": [
            {
              "default": "org.scalastyle.scalariform.CaseBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that package names match a regular expression.*\n\nThe Scala style guide recommends that package names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageNamesChecker-template",
          "name": "Package name",
          "params": [
            {
              "default": "^[a-z]+$",
              "description": "Regular expression: The package names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that package names match a regular expression.*\n\nThe Scala style guide recommends that package names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageNamesChecker",
          "name": "Package name",
          "params": [
            {
              "default": "^[a-z]+$",
              "description": "Regular expression: The package names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that package object names match a regular expression.*\n\nThe Scala style guide recommends that package object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageObjectNamesChecker-template",
          "name": "Package object name",
          "params": [
            {
              "default": "^[a-z][A-Za-z]*$",
              "description": "Regular expression: The package object names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that package object names match a regular expression.*\n\nThe Scala style guide recommends that package object names conform to certain standards.",
          "key": "org.scalastyle.scalariform.PackageObjectNamesChecker",
          "name": "Package object name",
          "params": [
            {
              "default": "^[a-z][A-Za-z]*$",
              "description": "Regular expression: The package object names must match this regular expression.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.PackageObjectNamesChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that pattern match arrows align.*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.PatternMatchAlignChecker",
          "name": "Pattern match align",
          "params": [
            {
              "default": "org.scalastyle.scalariform.PatternMatchAlignChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that a method has an explicit return type, it is not inferred.*\n\nA public method declared on a type is effectively an API declaration. Explicitly declaring a return type means that other code which depends on that type won't break unexpectedly.",
          "key": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker-template",
          "name": "Public method must have type",
          "params": [
            {
              "default": "false",
              "description": "Ignore overridden methods: If true, public methods which override are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that a method has an explicit return type, it is not inferred.*\n\nA public method declared on a type is effectively an API declaration. Explicitly declaring a return type means that other code which depends on that type won't break unexpectedly.",
          "key": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
          "name": "Public method must have type",
          "params": [
            {
              "default": "false",
              "description": "Ignore overridden methods: If true, public methods which override are ignored.",
              "name": "ignoreOverride",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*If a class/trait has no members, the braces are unnecessary.*\n\nIf a `class` / `trait` has no members, then braces are unnecessary, and can be removed.",
          "key": "org.scalastyle.scalariform.EmptyClassChecker",
          "name": "Redundant braces in class definition",
          "params": [
            {
              "default": "org.scalastyle.scalariform.EmptyClassChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that a regular expression cannot be matched, if found reports this.*\n\nSome checks can be carried out with a regular expression.",
          "key": "org.scalastyle.file.RegexChecker-template",
          "name": "Regular expression",
          "params": [
            {
              "default": "",
              "description": "Regular expression: Standard Scala regular expression syntax including multiline.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "false",
              "description": "Line: Boolean whether to process line by line.",
              "name": "line",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.RegexChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a regular expression cannot be matched in a token, if found reports this.*\n\nSome checks can be carried by just the presence of a particular token.",
          "key": "org.scalastyle.scalariform.TokenChecker-template",
          "name": "Regular expression in a token",
          "params": [
            {
              "default": "^$",
              "description": "Regular expression: Standard Scala regular expression syntax.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that a regular expression cannot be matched in a token, if found reports this.*\n\nSome checks can be carried by just the presence of a particular token.",
          "key": "org.scalastyle.scalariform.TokenChecker",
          "name": "Regular expression in a token",
          "params": [
            {
              "default": "^$",
              "description": "Regular expression: Standard Scala regular expression syntax.",
              "name": "regex",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that return is not used.*\n\nUse of `return` is not usually necessary in Scala. In fact, use of return can discourage a functional style of programming.",
          "key": "org.scalastyle.scalariform.ReturnChecker",
          "name": "Return",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ReturnChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Boolean expression can be simplified.*\n\nA boolean expression which can be simplified can make code easier to read.",
          "key": "org.scalastyle.scalariform.SimplifyBooleanExpressionChecker",
          "name": "Simplify Boolean expression",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SimplifyBooleanExpressionChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that the plus sign is followed by a space.*\n\nAn expression with spaces around `+` can be easier to read.",
          "key": "org.scalastyle.scalariform.SpacesAfterPlusChecker",
          "name": "Space after plus",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SpacesAfterPlusChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks a space after the start of the comment.*\n\nTo bring consistency with how comments should be formatted, leave a space right after the beginning of the comment.\n\n```scala\npackage foobar\n\nobject Foobar {\n  /**WRONG\n    *\n    */\n  /** Correct\n    *\n    */\n  val d = 2 /*Wrong*/ //Wrong\n  /**\n    * Correct\n    */\n  val e = 3 /** Correct*/ // Correct\n}\n```",
          "key": "org.scalastyle.scalariform.SpaceAfterCommentStartChecker",
          "name": "Space after the start of the comment",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SpaceAfterCommentStartChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Disallow space after certain token(s).*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.DisallowSpaceAfterTokenChecker",
          "name": "Space after tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.DisallowSpaceAfterTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that the plus sign is preceded by a space.*\n\nAn expression with spaces around `+` can be easier to read.",
          "key": "org.scalastyle.scalariform.SpacesBeforePlusChecker",
          "name": "Space before plus",
          "params": [
            {
              "default": "org.scalastyle.scalariform.SpacesBeforePlusChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Disallow space before certain token(s).*\n\nCorrect formatting can help readability.",
          "key": "org.scalastyle.scalariform.DisallowSpaceBeforeTokenChecker",
          "name": "Space before tokens",
          "params": [
            {
              "default": "org.scalastyle.scalariform.DisallowSpaceBeforeTokenChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that structural types are not used.*\n\nStructural types in Scala can use reflection - this can have unexpected performance consequences. Warning: This check can also wrongly pick up type lamdbas and other such constructs. This checker should be used with care. You always have the alternative of the scalac checking for structural types.",
          "key": "org.scalastyle.scalariform.StructuralTypeChecker",
          "name": "Structural type",
          "params": [
            {
              "default": "org.scalastyle.scalariform.StructuralTypeChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check for use of TODO/FIXME single line comments.*\n\nSome projects may consider `TODO` or `FIXME` comments in a code bad style. They would rather you fix the problem.",
          "key": "org.scalastyle.scalariform.TodoCommentChecker-template",
          "name": "TODO/FIXME comment",
          "params": [
            {
              "default": "TODO|FIXME",
              "description": "Word list: Alternative list of words to look for, separated by |.",
              "name": "words",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TodoCommentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check for use of TODO/FIXME single line comments.*\n\nSome projects may consider `TODO` or `FIXME` comments in a code bad style. They would rather you fix the problem.",
          "key": "org.scalastyle.scalariform.TodoCommentChecker",
          "name": "TODO/FIXME comment",
          "params": [
            {
              "default": "TODO|FIXME",
              "description": "Word list: Alternative list of words to look for, separated by |.",
              "name": "words",
              "typ": "String"
            },
            {
              "default": "org.scalastyle.scalariform.TodoCommentChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that the code does not have ??? operators.*\n\nThe `???` operator denotes that an implementation is missing. This rule helps to avoid potential runtime errors because of not implemented code.",
          "key": "org.scalastyle.scalariform.NotImplementedErrorUsage",
          "name": "Usage of ??? operator",
          "params": [
            {
              "default": "org.scalastyle.scalariform.NotImplementedErrorUsage",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Use a : Unit = for procedure declarations.*\n\nA procedure style declaration can cause confusion - the developer may have simply forgotten to add a `=`, and now their method returns `Unit` rather than the inferred type:\n\n```scala\ndef foo() { println(\"hello\"); 5 }\n```\nThis checker raises a warning with the first line. To fix it, use an explicit return type, or add a `=` before the body.\n\n```scala\ndef foo() = { println(\"hello\"); 5 }\n```",
          "key": "org.scalastyle.scalariform.ProcedureDeclarationChecker",
          "name": "Use : Unit = for procedures",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ProcedureDeclarationChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that braces are used in for comprehensions.*\n\nUsage of braces (rather than parentheses) within a `for` comprehension mean that you don't have to specify a semi-colon at the end of every line:\n\n```scala\nfor { // braces\n  t <- List(1,2,3)\n  if (t % 2 == 0)\n} yield t\n```\n\nis preferred to\n\n```scala\nfor ( // parentheses\n  t <- List(1,2,3);\n  if (t % 2 == 0)\n) yield t\n```\n\nTo fix it, replace the `()` with `{}`. And then remove the `;` at the end of the lines.\n\nThe `singleLineAllowed` property allows for constructions of the type:\n\n```scala\nfor (i <- List(1,2,3)) yield i\n```",
          "key": "org.scalastyle.scalariform.ForBraceChecker-template",
          "name": "Use braces in for comprehensions",
          "params": [
            {
              "default": "false",
              "description": "Allow parentheses for single-line for: For with parentheses allowed if everything is on one line.",
              "name": "singleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.ForBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that braces are used in for comprehensions.*\n\nUsage of braces (rather than parentheses) within a `for` comprehension mean that you don't have to specify a semi-colon at the end of every line:\n\n```scala\nfor { // braces\n  t <- List(1,2,3)\n  if (t % 2 == 0)\n} yield t\n```\n\nis preferred to\n\n```scala\nfor ( // parentheses\n  t <- List(1,2,3);\n  if (t % 2 == 0)\n) yield t\n```\n\nTo fix it, replace the `()` with `{}`. And then remove the `;` at the end of the lines.\n\nThe `singleLineAllowed` property allows for constructions of the type:\n\n```scala\nfor (i <- List(1,2,3)) yield i\n```",
          "key": "org.scalastyle.scalariform.ForBraceChecker",
          "name": "Use braces in for comprehensions",
          "params": [
            {
              "default": "false",
              "description": "Allow parentheses for single-line for: For with parentheses allowed if everything is on one line.",
              "name": "singleLineAllowed",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.scalariform.ForBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that lines are indented by a multiple of the tab size.*\n\nCode that is not indented consistently can be hard to read.",
          "key": "org.scalastyle.file.IndentationChecker-template",
          "name": "Use correct indentation",
          "params": [
            {
              "default": "2",
              "description": "Tab size: Number of characters that a tab represents.",
              "name": "tabSize",
              "typ": "Integer"
            },
            {
              "default": "2",
              "description": "Multi-line method parameter spacing: Level of indentation of multi-line method parameters relative to the indentation of the first line of the method.",
              "name": "methodParamIndentSize",
              "typ": "Integer"
            },
            {
              "default": "4",
              "description": "Multi-line class parameter spacing: Level of indentation of multi-line primary constructor parameters of a class. Relative to the indentation of the first line of class declaration.",
              "name": "classParamIndentSize",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.file.IndentationChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Checks that lines are indented by a multiple of the tab size.*\n\nCode that is not indented consistently can be hard to read.",
          "key": "org.scalastyle.file.IndentationChecker",
          "name": "Use correct indentation",
          "params": [
            {
              "default": "2",
              "description": "Tab size: Number of characters that a tab represents.",
              "name": "tabSize",
              "typ": "Integer"
            },
            {
              "default": "2",
              "description": "Multi-line method parameter spacing: Level of indentation of multi-line method parameters relative to the indentation of the first line of the method.",
              "name": "methodParamIndentSize",
              "typ": "Integer"
            },
            {
              "default": "4",
              "description": "Multi-line class parameter spacing: Level of indentation of multi-line primary constructor parameters of a class. Relative to the indentation of the first line of class declaration.",
              "name": "classParamIndentSize",
              "typ": "Integer"
            },
            {
              "default": "org.scalastyle.file.IndentationChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that parentheses are used in for loops.*\n\nFor-comprehensions which lack a `yield` clause is actually a loop rather than a functional comprehension and it is usually more readable to string the generators together between parentheses rather than using the syntactically-confusing `} {` construct:\n\n```scala\nfor (x <- board.rows; y <- board.files) {\n  printf(\"(%d, %d)\", x, y)\n}\n```\n\nis preferred to\n\n```scala\nfor {\n  x <- board.rows\n  y <- board.files\n} {\n  printf(\"(%d, %d)\", x, y)\n}\n```",
          "key": "org.scalastyle.scalariform.ForLoopChecker",
          "name": "Use parentheses in for loops",
          "params": [
            {
              "default": "org.scalastyle.scalariform.ForLoopChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks that while body have braces.*\n\nWhile cannot be used in a pure-functional manner, that's why it's recommended to never omit braces according to Scala Style Guide.",
          "key": "org.scalastyle.scalariform.WhileBraceChecker",
          "name": "While body should have braces",
          "params": [
            {
              "default": "org.scalastyle.scalariform.WhileBraceChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that there is no trailing whitespace at the end of lines.*\n\nWhitespace at the end of a line can cause problems when diffing between files or between versions.",
          "key": "org.scalastyle.file.WhitespaceEndOfLineChecker-template",
          "name": "Whitespace at end of line",
          "params": [
            {
              "default": "false",
              "description": "Ignore lines with just whitespace: Skip a line if the entire contents are whitespace characters.",
              "name": "ignoreWhitespaceLines",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.WhitespaceEndOfLineChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": true
        },
        {
          "description": "*Check that there is no trailing whitespace at the end of lines.*\n\nWhitespace at the end of a line can cause problems when diffing between files or between versions.",
          "key": "org.scalastyle.file.WhitespaceEndOfLineChecker",
          "name": "Whitespace at end of line",
          "params": [
            {
              "default": "false",
              "description": "Ignore lines with just whitespace: Skip a line if the entire contents are whitespace characters.",
              "name": "ignoreWhitespaceLines",
              "typ": "Boolean"
            },
            {
              "default": "org.scalastyle.file.WhitespaceEndOfLineChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Check that XML literals are not used.*\n\nSome projects prefer not to have XML literals. They could use a templating engine instead.",
          "key": "org.scalastyle.scalariform.XmlLiteralChecker",
          "name": "XML literals",
          "params": [
            {
              "default": "org.scalastyle.scalariform.XmlLiteralChecker",
              "description": "Scalastyle's rule (checker) class name.",
              "name": "ruleClass",
              "typ": "String"
            }
          ],
          "severity": "Minor",
          "template": false
        }
      ]
    },
    "sonar-scala-scapegoat": {
      "key": "sonar-scala-scapegoat",
      "name": "Scapegoat",
      "rules": [
        {
          "description": "*Checks whether !isEmpty can be replaced with nonEmpty.*\n\n!.isEmpty can be replaced with.nonEmpty to make it easier to reason about.",
          "key": "com.sksamuel.scapegoat.inspections.collections.NegationIsEmpty",
          "name": "!isEmpty can be replaced with nonEmpty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks whether !nonEmpty can be replaced with isEmpty.*\n\n!.nonEmpty can be replaced with.isEmpty to make it easier to reason about.",
          "key": "com.sksamuel.scapegoat.inspections.collections.NegationNonEmpty",
          "name": "!nonEmpty can be replaced with isEmpty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for comparison of arrays using == which will always return false.*\n\nArray equals is not an equality check. Use a.deep == b.deep or convert to another collection type.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ArrayEquals",
          "name": "Array equals",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for arrays passed to String.format.*\n\nAn Array passed to String.format might result in an incorrect formatting.",
          "key": "com.sksamuel.scapegoat.inspections.string.ArraysInFormat",
          "name": "Array passed to String.format",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for ranges using (j to k - 1).*\n\nA range in the following format (j to k - 1) can be simplified to (j until k).",
          "key": "com.sksamuel.scapegoat.inspections.AvoidToMinusOne",
          "name": "Avoid (j to k - 1)",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of Traversable.size.*\n\n.size can be slow for some data structures, prefer .nonEmpty, which is O(1).",
          "key": "com.sksamuel.scapegoat.inspections.collections.AvoidSizeNotEqualsZero",
          "name": "Avoid Traversable.size != 0",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of Traversable.size.*\n\nTraversable.size can be slow for some data structures, prefer Traversable.isEmpty, which is O(1).",
          "key": "com.sksamuel.scapegoat.inspections.collections.AvoidSizeEqualsZero",
          "name": "Avoid Traversable.size == 0",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for symbolic method names.*\n\nScala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.",
          "key": "com.sksamuel.scapegoat.inspections.style.AvoidOperatorOverload",
          "name": "Avoid operator overload",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of BigDecimal(double) which can be unsafe.*\n\nThe results of this constructor can be somewhat unpredictable. E.g. writing new BigDecimal(0.1) in Java creates a BigDecimal which is actually equal to 0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double.",
          "key": "com.sksamuel.scapegoat.inspections.math.BigDecimalDoubleConstructor",
          "name": "Big decimal double constructor",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of `setScale()` on a BigDecimal without setting the rounding mode can throw an exception.*\n\nWhen using `setScale()` on a BigDecimal without setting the rounding mode, this can throw an exception if rounding is required. Did you mean to call `setScale(s, RoundingMode.XYZ)`?",
          "key": "com.sksamuel.scapegoat.inspections.math.BigDecimalScaleWithoutRoundingMode",
          "name": "BigDecimal setScale() without rounding mode",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for types with upper bounds of a final type.*\n\nPointless type bound. Type parameter can only be a single value.",
          "key": "com.sksamuel.scapegoat.inspections.inference.BoundedByFinalType",
          "name": "Bounded by a final type",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for potentially broken odd checks.*\n\nCode that attempts to check for oddness using `x % 2 == 1` will fail on negative numbers. Consider using `x % 2 != 0`.",
          "key": "com.sksamuel.scapegoat.inspections.math.BrokenOddness",
          "name": "Broken odd check",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for try blocks that catch exception.*\n\nDid you intend to catch all exceptions? Consider catching a more specific exception class.",
          "key": "com.sksamuel.scapegoat.inspections.exception.CatchException",
          "name": "Catch exception",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for try blocks that catch fatal exceptions: VirtualMachineError, ThreadDeath, InterruptedException, LinkageError, ControlThrowable.*\n\nDid you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.",
          "key": "com.sksamuel.scapegoat.inspections.exception.CatchFatal",
          "name": "Catch fatal exception",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for try blocks that catch Throwable.*\n\nDid you intend to catch all throwables? Consider catching a more specific exception class.",
          "key": "com.sksamuel.scapegoat.inspections.exception.CatchThrowable",
          "name": "Catch throwable",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for try blocks that catch null pointer exceptions.*\n\nAvoid using null at all cost and you shouldn't need to catch NullPointerExceptions. Prefer Option to indicate potentially missing values and use Try to materialize exceptions thrown by any external libraries.",
          "key": "com.sksamuel.scapegoat.inspections.exception.CatchNpe",
          "name": "Catching NPE",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Ensures class names adhere to the style guidelines.*\n\nClass names should begin with uppercase letter.",
          "key": "com.sksamuel.scapegoat.inspections.naming.ClassNames",
          "name": "Class name not recommended",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for negative access on a sequence, e.g. list.get(-1).*\n\nTrying to access Seq elements using a negative index will result in an IndexOutOfBoundsException.",
          "key": "com.sksamuel.scapegoat.inspections.collections.CollectionNegativeIndex",
          "name": "Collection index out of bounds",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for variables that are confusingly named.*\n\nE.g. an instance of a Set is confusingly referred to by a variable called/containing list, or the other way around.",
          "key": "com.sksamuel.scapegoat.inspections.collections.CollectionNamingConfusion",
          "name": "Collection naming confusion",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for collection operations that promote the collection to Any.*\n\nThe `:+` (append) operator on collections accepts any argument you give it, which means that you can end up with e.g. `Seq[Any]` if your types don't match.",
          "key": "com.sksamuel.scapegoat.inspections.collections.CollectionPromotionToAny",
          "name": "Collection promotion to Any",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for equality comparisons that cannot succeed.*\n\nIn most case comparing unrelated types cannot succeed and it's usually an indication of a bug.",
          "key": "com.sksamuel.scapegoat.inspections.equality.ComparingUnrelatedTypes",
          "name": "Comparing unrelated types",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for equality checks with itself.*\n\nComparison with self will always yield true.",
          "key": "com.sksamuel.scapegoat.inspections.equality.ComparisonWithSelf",
          "name": "Comparision with self",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for code like `a == List()` or `a == Nil`.*\n\nPrefer use of `isEmpty` instead of comparison to an empty List.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ComparisonToEmptyList",
          "name": "Comparison to empty list",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for code like `a == Set()` or `a == Set.empty`.*\n\nPrefer use of `isEmpty` instead of comparison to an empty Set.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ComparisonToEmptySet",
          "name": "Comparison to empty set",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for code where the if condition compiles to a constant.*\n\nAn if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.ConstantIf",
          "name": "Constant if expression",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for division by one.*\n\nDivide by one will always return the original value.",
          "key": "com.sksamuel.scapegoat.inspections.math.DivideByOne",
          "name": "Divide by one",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for code like !(!b).*\n\nDouble negation can be removed, e.g. !(!b) it equal to just b.",
          "key": "com.sksamuel.scapegoat.inspections.DoubleNegation",
          "name": "Double negation",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for duplicate import statements.*\n\nDuplicate imports should be removed.",
          "key": "com.sksamuel.scapegoat.inspections.imports.DuplicateImport",
          "name": "Duplicate import",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for duplicate key names in Map literals.*\n\nA map key is overwritten by a later entry.",
          "key": "com.sksamuel.scapegoat.inspections.collections.DuplicateMapKey",
          "name": "Duplicated map key",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for duplicate values in set literals.*\n\nA set value is overwritten by a later entry.",
          "key": "com.sksamuel.scapegoat.inspections.collections.DuplicateSetValue",
          "name": "Duplicated set value",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for empty case classes like, e.g. case class Faceman().*\n\nAn empty case class can be rewritten as a case object.",
          "key": "com.sksamuel.scapegoat.inspections.EmptyCaseClass",
          "name": "Empty case class",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Finds catch blocks that don't handle caught exceptions.*\n\nIf you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.",
          "key": "com.sksamuel.scapegoat.inspections.exception.SwallowedException",
          "name": "Empty catch block",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for empty for loops.*\n\nAn empty for loop isn't a common practice and in most cases is considered as dead code.",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyFor",
          "name": "Empty for loop",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for empty if blocks.*\n\nAn empty if block is considered as dead code.",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyIfBlock",
          "name": "Empty if expression",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Looks for interpolated strings that have no arguments.*\n\nString declared as interpolated but has no parameters can be turned into a regular string.",
          "key": "com.sksamuel.scapegoat.inspections.string.EmptyInterpolatedString",
          "name": "Empty interpolated string",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for empty method statements.*\n\nAn empty method is considered as dead code.",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyMethod",
          "name": "Empty method",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for empty synchronized blocks.*\n\nAn empty synchronized block is considered as dead code.",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptySynchronizedBlock",
          "name": "Empty synchronized block",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for empty try blocks.*\n\nAn empty try block is considered as dead code.",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyTryBlock",
          "name": "Empty try block",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for empty while blocks.*\n\nAn empty while block is considered as dead code.",
          "key": "com.sksamuel.scapegoat.inspections.empty.EmptyWhileBlock",
          "name": "Empty while block",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks if `exists()` can be simplified to `contains()`.*\n\n`exists(x => x == y)` can be replaced with `contains(y)`.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ExistsSimplifiableToContains",
          "name": "Exists simplifiable to contains",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for overridden finalizers that do not call super.*\n\nFinalizers should call `super.finalize()` to ensure superclasses are able to run their finalization logic.",
          "key": "com.sksamuel.scapegoat.inspections.unsafe.FinalizerWithoutSuper",
          "name": "Finalizer without super",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for equality checks on floating point types.*\n\nDue to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.",
          "key": "com.sksamuel.scapegoat.inspections.equality.ComparingFloatingPointTypes",
          "name": "Floating type comparison",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for invalid format strings.*\n\nAn unchecked exception will be thrown when a format string contains an illegal syntax or a format specifier that is incompatible with the given arguments.",
          "key": "com.sksamuel.scapegoat.inspections.string.IllegalFormatString",
          "name": "Illegal format string",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for code like option.size > 1.*\n\nOption.size > 1 can never be true, did you mean to use Option.nonEmpty instead?",
          "key": "com.sksamuel.scapegoat.inspections.option.ImpossibleOptionSizeCondition",
          "name": "Impossible Option.size condition",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for wrong number of arguments to String.format.*\n\nThe number of arguments passed to String.format doesn't correspond to the number of fields in the format string.",
          "key": "com.sksamuel.scapegoat.inspections.string.IncorrectNumberOfArgsToFormat",
          "name": "Incorrect number of args for format",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for exceptions that are not called *Exception and vice versa.*\n\nClass named exception does not derive from Exception / class derived from Exception is not named *Exception.",
          "key": "com.sksamuel.scapegoat.inspections.exception.IncorrectlyNamedExceptions",
          "name": "Incorrectly named exceptions",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for expressions like x % 1.*\n\nAny expression x % 1 will always return 0.",
          "key": "com.sksamuel.scapegoat.inspections.math.ModOne",
          "name": "Integer mod one",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for invalid regex literals.*\n\nInvalid regex literals can fail at compile time with a PatternSyntaxException. This could be caused by e.g. dangling meta characters, or unclosed escape characters, etc.",
          "key": "com.sksamuel.scapegoat.inspections.string.InvalidRegex",
          "name": "Invalid regex",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of Java conversions.*\n\nUse of Java conversions can lead to unusual behaviour. It is recommended to use JavaConverters.",
          "key": "com.sksamuel.scapegoat.inspections.collections.JavaConversionsUse",
          "name": "Java conversions",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for when elements are appended to a list.*\n\nList append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer, Vector or a cats.data.Chain (which has constant prepend and append).",
          "key": "com.sksamuel.scapegoat.inspections.collections.ListAppend",
          "name": "List append is slow",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of List.size.*\n\nList.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ListSize",
          "name": "List.size is O(n)",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for sealed traits without any classes extending it.*\n\nA sealed trait that is not extended is considered dead code.",
          "key": "com.sksamuel.scapegoat.inspections.LonelySealedTrait",
          "name": "Lonely sealed trait",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for strings that look like they should be interpolated.*\n\nDid you forget to prefix this string with an s, f or raw to interpolate it?",
          "key": "com.sksamuel.scapegoat.inspections.string.LooksLikeInterpolatedString",
          "name": "Looks like interpolated String",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Warns when you could use a partial function directly instead of a match block.*\n\nA map match can be replaced with a partial function for greater readability.",
          "key": "com.sksamuel.scapegoat.inspections.matching.PartialFunctionInsteadOfMatch",
          "name": "Match instead of a partial function",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for methods that have over 10 parameters.*\n\nMethods having a large number of parameters are more difficult to reason about, consider refactoring this code.",
          "key": "com.sksamuel.scapegoat.inspections.MaxParameters",
          "name": "Max parameters",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Warns on method names that don't adhere to the Scala style guidelines.*\n\nMethods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.",
          "key": "com.sksamuel.scapegoat.inspections.naming.MethodNames",
          "name": "Method name not recommended",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for functions that are defined or inferred to return Any.*\n\nMethod returns Any. Consider using a more specialized type.",
          "key": "com.sksamuel.scapegoat.inspections.inference.MethodReturningAny",
          "name": "Method returning Any",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for case classes without a final modifier.*\n\nUsing case classes without final modifier can lead to surprising breakage.",
          "key": "com.sksamuel.scapegoat.inspections.FinalModifierOnCaseClass",
          "name": "Missing final modifier on case class",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for x == Double.NaN which will always fail.*\n\nNaN comparison will always fail. Use value.isNan instead.",
          "key": "com.sksamuel.scapegoat.inspections.math.NanComparison",
          "name": "Nan comparison",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for code that overrides parent method but simply calls super.*\n\nThis method is overridden yet only calls super.",
          "key": "com.sksamuel.scapegoat.inspections.NoOpOverride",
          "name": "Noop override",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of null in assignments.*\n\nUse an Option instead when the value can be empty.",
          "key": "com.sksamuel.scapegoat.inspections.nulls.NullAssignment",
          "name": "Null assignment",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of null in method invocation.*\n\nUse an Option instead when the value can be empty and pass down a None instead.",
          "key": "com.sksamuel.scapegoat.inspections.nulls.NullParameter",
          "name": "Null parameter",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Ensures object names adhere to the Scala style guidelines.*\n\nObject names should only contain alphanumeric characters.",
          "key": "com.sksamuel.scapegoat.inspections.naming.ObjectNames",
          "name": "Object name not recommended",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for methods returning Unit that are defined without empty parentheses.*\n\nMethods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().",
          "key": "com.sksamuel.scapegoat.inspections.style.ParameterlessMethodReturnsUnit",
          "name": "Parameterless methods returns unit",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Finds type bounds of the form `A <: Any` or `A >: Nothing`.*\n\nType bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?",
          "key": "com.sksamuel.scapegoat.inspections.inference.PointlessTypeBounds",
          "name": "Pointless type bounds",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of Map().*\n\n`Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.",
          "key": "com.sksamuel.scapegoat.inspections.collections.PreferMapEmpty",
          "name": "Prefer Map.empty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of Option.size.*\n\nPrefer to use Option.isDefined, Option.isEmpty or Option.nonEmpty instead of Option.size.",
          "key": "com.sksamuel.scapegoat.inspections.option.OptionSize",
          "name": "Prefer Option.isDefined instead of Option.size",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for use of Seq().*\n\n`Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.",
          "key": "com.sksamuel.scapegoat.inspections.collections.PreferSeqEmpty",
          "name": "Prefer Seq.empty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of Set().*\n\n`Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.",
          "key": "com.sksamuel.scapegoat.inspections.collections.PreferSetEmpty",
          "name": "Prefer Set.empty",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for values that have Product with Serializable as their inferred type.*\n\nIt is unlikely that Product with Serializable was your target type. This is often an indication of mixing up incompatible types.",
          "key": "com.sksamuel.scapegoat.inspections.inference.ProductWithSerializableInferred",
          "name": "Product with Serializable inferred",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for overridden finalizes that are public.*\n\nPublic finalizer should be avoided as finalizers should not be programmatically invoked.",
          "key": "com.sksamuel.scapegoat.inspections.PublicFinalizer",
          "name": "PublicFinalizer",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for redundant final modifiers on methods.*\n\nA final modifier on methods that cannot be overridden is redundant.",
          "key": "com.sksamuel.scapegoat.inspections.RedundantFinalModifierOnMethod",
          "name": "Redundant final modifier on a method",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for redundant final modifier on vars.*\n\nA final modifier on a var that cannot be overridden is redundant.",
          "key": "com.sksamuel.scapegoat.inspections.RedundantFinalModifierOnVar",
          "name": "Redundant final modifier on a var",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for empty finalizers.*\n\nAn empty finalizer, e.g. override def finalize: Unit = {} is redundant and should be removed.",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.RedundantFinalizer",
          "name": "Redundant finalizer",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for the main branch and the else branch of an if being the same.*\n\nThe if statement could be refactored if both branches are the same or start with the same.",
          "key": "com.sksamuel.scapegoat.inspections.controlflow.RepeatedIfElseBody",
          "name": "Repeated body of if main and else branch",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for case statements which have the same body.*\n\nCase body is repeated. Consider merging pattern clauses together.",
          "key": "com.sksamuel.scapegoat.inspections.matching.RepeatedCaseBody",
          "name": "Repeated case body",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for boolean expressions that can be simplified.*\n\nBoolean expressions such as x == false can be re-written as !x.",
          "key": "com.sksamuel.scapegoat.inspections.style.SimplifyBooleanExpression",
          "name": "Simplify boolean expressions",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for String.substring(0).*\n\nUse of String.substring(0) will always return the same string.",
          "key": "com.sksamuel.scapegoat.inspections.string.SubstringZero",
          "name": "String.substring(0)",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for .stripMargin calls on regex strings that contain a pipe.*\n\nStrip margin will strip | from regex - possible corrupted regex.",
          "key": "com.sksamuel.scapegoat.inspections.string.StripMarginOnRegex",
          "name": "Strip margin on regex",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for code where matching is taking place on class literals.*\n\nMatching on an companion object of a case class is probably not what you intended.",
          "key": "com.sksamuel.scapegoat.inspections.matching.SuspiciousMatchOnClassObject",
          "name": "Suspicious match on class object",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for an inefficient use of filter.sort.*\n\nFilter first and then sort the remaining collection. Swap sort.filter for filter.sort for better performance.",
          "key": "com.sksamuel.scapegoat.inspections.collections.SwapSortFilter",
          "name": "Swap sort filter",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for shadowed type parameters in methods.*\n\nShadowing type parameters is considered a bad practice and should be avoided.",
          "key": "com.sksamuel.scapegoat.inspections.TypeShadowing",
          "name": "Type shadowing",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for unnecessary toInt on instances of Int or toString on Strings, etc.*\n\nCalling e.g. toString on a String or toList on a List is completely unnecessary and it's an equivalent to identity.",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryConversion",
          "name": "Unnecessary conversion",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for code like if (expr) true else false.*\n\nIf comparison is not needed. Use the condition, e.g. instead of if (a == b) true else false, use a == b or instead of if (a == b) false else true, use !(a == b).",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryIf",
          "name": "Unnecessary if condition.",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of return keyword in blocks.*\n\nScala returns the value of the last expression in a block. Use of return here is not an idiomatic Scala.",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryReturnUse",
          "name": "Unnecessary return",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of reverse followed by head/headOption/iterator/map.*\n\n`reverse` followed by `head`, `headOption`, `iterator`, or `map` can be replaced, respectively, with `last`, `lastOption`, `reverseIterator`, or `reverseMap`.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ReverseFunc",
          "name": "Unnecessary reverse",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for catch clauses that cannot be reached.*\n\nOne or more cases are unreachable.",
          "key": "com.sksamuel.scapegoat.inspections.exception.UnreachableCatch",
          "name": "Unreachable catch",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks `Seq.contains()` and `Option.contains()` for unrelated types.*\n\n`contains()` accepts arguments af any type, which means you might be checking if your collection contains an element of an unrelated type.",
          "key": "com.sksamuel.scapegoat.inspections.collections.UnsafeContains",
          "name": "Unsafe contains",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for String.contains(value) for invalid types.*\n\nString.contains() accepts arguments af any type, which means you might be checking if your string contains an element of an unrelated type.",
          "key": "com.sksamuel.scapegoat.inspections.string.UnsafeStringContains",
          "name": "Unsafe string contains",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for unused method parameters.*\n\nUnused constructor or method parameters should be removed.",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnusedMethodParameter",
          "name": "Unused parameter",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of math.pow for calculating math.cbrt.*\n\nUse math.cbrt, which is clearer and more performant than math.pow(x, 1/3).",
          "key": "com.sksamuel.scapegoat.inspections.math.UseCbrt",
          "name": "Use cbrt",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of math.exp(x) - 1 instead of math.expm1(x).*\n\nUse math.expm1(x), which is clearer and more performant than math.exp(x) - 1.",
          "key": "com.sksamuel.scapegoat.inspections.math.UseExpM1",
          "name": "Use expm1",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of math.log(x)/math.log(10) instead of math.log10(x).*\n\nUse math.log10(x), which is clearer and more performant than $math.log(x)/$math.log(10).",
          "key": "com.sksamuel.scapegoat.inspections.math.UseLog10",
          "name": "Use log10",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of math.log(x + 1) instead of math.log1p(x).*\n\nUse math.log1p(x) is clearer and more performant than $math.log(1 + x).",
          "key": "com.sksamuel.scapegoat.inspections.math.UseLog1P",
          "name": "Use log1p",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for explicit toString calls on arrays.*\n\nCalling toString on an array does not perform a deep toString.",
          "key": "com.sksamuel.scapegoat.inspections.string.ArraysToString",
          "name": "Use of Array.toString",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of .get on Left or Right projection.*\n\nMethod .get on a Left and a Right projection is deprecated since 2.13, use Either.getOrElse or Either.swap.getOrElse instead.",
          "key": "com.sksamuel.scapegoat.inspections.option.EitherGet",
          "name": "Use of Either.right or Either.left projection followed by a get",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks whether Map.get().getOrElse() can be simplified to Map.getOrElse().*\n\nMap.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.",
          "key": "com.sksamuel.scapegoat.inspections.collections.MapGetAndGetOrElse",
          "name": "Use of Map.get().getOrElse instead of Map.getOrElse",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for use of Option.get.*\n\nUsing Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.",
          "key": "com.sksamuel.scapegoat.inspections.option.OptionGet",
          "name": "Use of Option.get",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for use of Try.get.*\n\nUsing Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.",
          "key": "com.sksamuel.scapegoat.inspections.unsafe.TryGet",
          "name": "Use of Try.get",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for indexing on a Seq which is not an IndexedSeq.*\n\nUsing an index to access elements of an IndexedSeq may cause performance problems.",
          "key": "com.sksamuel.scapegoat.inspections.collections.CollectionIndexOnNonIndexedSeq",
          "name": "Use of apply method on a non-indexed Seq",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of asInstanceOf.*\n\nUse of asInstanceOf is considered a bad practice - consider using pattern matching instead.",
          "key": "com.sksamuel.scapegoat.inspections.unsafe.AsInstanceOf",
          "name": "Use of asInstanceOf",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of isInstanceOf.*\n\nUse of isInstanceOf is considered a bad practice - consider using pattern matching instead.",
          "key": "com.sksamuel.scapegoat.inspections.unsafe.IsInstanceOf",
          "name": "Use of isInstanceOf",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of unsafe methods on Traversable.*\n\nThe following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).",
          "key": "com.sksamuel.scapegoat.inspections.collections.UnsafeTraversableMethods",
          "name": "Use of unsafe Traversable methods.",
          "params": [],
          "severity": "Major",
          "template": false
        },
        {
          "description": "*Checks for use of math.pow for calculating math.sqrt.*\n\nUse math.sqrt, which is clearer and more performant than $math.pow(x, 0.5).",
          "key": "com.sksamuel.scapegoat.inspections.math.UseSqrt",
          "name": "Use sqrt",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for vars that could be declared as vals.*\n\nA variable (var) that is never written to could be turned into a value (val).",
          "key": "com.sksamuel.scapegoat.inspections.unneccesary.VarCouldBeVal",
          "name": "Var could be val",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Finds closures that reference variables (var).*\n\nClosing over a var can lead to subtle bugs.",
          "key": "com.sksamuel.scapegoat.inspections.VarClosure",
          "name": "Var in closure",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for multiple uses of the variable name in nested scopes.*\n\nVariable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.",
          "key": "com.sksamuel.scapegoat.inspections.VariableShadowing",
          "name": "Variable shadowing",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for code that uses a while(true) or do {...} while(true) block.*\n\nA (do) while true loop is unlikely to be meant for production.",
          "key": "com.sksamuel.scapegoat.inspections.controlflow.WhileTrue",
          "name": "While true loop",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for dividing 0 by a number.*\n\nDividing zero by any number will always return zero, e.g. 0 / x == 0.",
          "key": "com.sksamuel.scapegoat.inspections.math.ZeroNumerator",
          "name": "Zero numerator",
          "params": [],
          "severity": "Minor",
          "template": false
        },
        {
          "description": "*Checks for use of filter().head.*\n\n`filter().head` can throw an exception if the collection is empty - it can be replaced with `find() match {...}`.",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotHead",
          "name": "filter().head can throw an exception",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of filter().headOption.*\n\n`filter()` scans the entire collection, which is unnecessary if you only want to get the first element that satisfies the predicate - `filter().headOption` can be replaced with `find()` to potentially avoid scanning the entire collection.",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotHeadOption",
          "name": "filter().headOption instead of find()",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of filter().isEmpty.*\n\n`filter()` scans the entire collection, which can potentially be avoided if the element exists in the collection - `filter().isEmpty` can be replaced with `!exists()`.",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotIsEmpty",
          "name": "filter().isEmpty instead of !exists()",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks if filter().size can be simplified to count().*\n\n`filter().size` can be replaced with `count()`, which is more concise.",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotSize",
          "name": "filter().size() instead of count()",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks whether the expression can be rewritten using flatten.*\n\n`filter(_.isDefined).map(_.get)` can be replaced with `flatten`.",
          "key": "com.sksamuel.scapegoat.inspections.collections.FilterOptionAndGet",
          "name": "filter(_.isDefined).map(_.get) instead of flatten",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks whether `find()` can be replaced with `exists()`.*\n\n`find().isDefined` can be replaced with `exists()`, which is more concise.",
          "key": "com.sksamuel.scapegoat.inspections.collections.FindDotIsDefined",
          "name": "find().isDefined() instead of exists()",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks whether `find()` can be replaced with exists().*\n\n`find() != None` can be replaced with `exists()`, which is more concise.",
          "key": "com.sksamuel.scapegoat.inspections.collections.FindAndNotEqualsNoneReplaceWithExists",
          "name": "find(x => ) != None instead of exists(x =>)",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of reverse.tail.reverse.*\n\n`reverse.tail.reverse` can be replaced with `init`, which is more concise.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ReverseTailReverse",
          "name": "reverse.tail.reverse instead of init",
          "params": [],
          "severity": "Info",
          "template": false
        },
        {
          "description": "*Checks for use of reverse.take().reverse.*\n\n`reverse.take().reverse` can be replaced with `takeRight`, which is more concise.",
          "key": "com.sksamuel.scapegoat.inspections.collections.ReverseTakeReverse",
          "name": "reverse.take().reverse instead of takeRight",
          "params": [],
          "severity": "Info",
          "template": false
        }
      ]
    }
  },
  "rules": {
    "scalastyle": [
      {
        "description": "*Checks that block imports are not used.*\n\nBlock imports, e.g. `import a.{b, c}` can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports are used in order to minimize merge errors in import declarations.",
        "key": "org.scalastyle.scalariform.BlockImportChecker",
        "name": "Avoid block imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that curlies imports are not used.*\n\nCurlies imports, e.g. `import a.{b, c}`, can lead to annoying merge errors in large code bases that are maintained by lot of developers. This rule allows to ensure that only single imports, no renaming and no hiding imports are used in order to minimize merge errors in import declarations.",
        "key": "org.scalastyle.scalariform.CurliesImportChecker",
        "name": "Avoid curlies imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Avoid wildcard imports.*\n\nImporting all classes from a package or static members from a class leads to tight coupling between packages or classes and might lead to problems when a new version of a library introduces name clashes.",
        "key": "org.scalastyle.scalariform.UnderscoreImportChecker",
        "name": "Avoid wildcard imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that class names match a regular expression.*\n\nThe Scala style guide recommends that class names conform to certain standards.",
        "key": "org.scalastyle.scalariform.ClassNamesChecker",
        "name": "Class name",
        "params": [
          {
            "default": "^[A-Z][A-Za-z]*$",
            "description": "Regular expression: The class names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that type parameter to a class matches a regular expression.*\n\nScala generic type names are generally single upper case letters. This check checks for classes and traits. Note that this check only checks the innermost type parameter, to allow for `List[T]`.",
        "key": "org.scalastyle.scalariform.ClassTypeParameterChecker",
        "name": "Class type parameter name",
        "params": [
          {
            "default": "^[A-Z_]$",
            "description": "Regular expression: Standard Scala regular expression syntax.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that classes and objects do not define the clone() method.*\n\nThe clone method is difficult to get right. You can use the copy constructor of case classes rather than implementing clone. For more information on `clone()`, see Effective Java by Joshua Bloch pages.",
        "key": "org.scalastyle.scalariform.NoCloneChecker",
        "name": "Clone method",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that classes and objects do not define equals without overriding equals(java.lang.Object).*\n\nMistakenly defining a covariant `equals()` method without overriding method `equals(java.lang.Object)` can produce unexpected runtime behaviour.",
        "key": "org.scalastyle.scalariform.CovariantEqualsChecker",
        "name": "Covariant equals",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that the cyclomatic complexity of a method does exceed a value.*\n\nIf the code is too complex, then this can make code hard to read.",
        "key": "org.scalastyle.scalariform.CyclomaticComplexityChecker",
        "name": "Cyclomatic complexity",
        "params": [
          {
            "default": "10",
            "description": "Maximum: Maximum cyclomatic complexity to allow for a method.",
            "name": "maximum",
            "typ": "Integer"
          },
          {
            "default": "true",
            "description": "Count Cases: If true, each case increases method complexity, else only match keyword is considered.",
            "name": "countCases",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*The interpolation for this string literal is not necessary.*\n\nEmpty interpolated strings are harder to read and not necessary.",
        "key": "org.scalastyle.scalariform.EmptyInterpolatedStringChecker",
        "name": "Empty interpolated string",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that if a class implements either equals or hashCode, it should implement the other.*\n\nDefining either equals or hashCode in a class without defining the is a known source of bugs. Usually, when you define one, you should also define the other.",
        "key": "org.scalastyle.scalariform.EqualsHashCodeChecker",
        "name": "Equals hashCode",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that field names match a regular expression.*\n\nA consistent naming convention for field names can make code easier to read and understand.",
        "key": "org.scalastyle.scalariform.FieldNamesChecker",
        "name": "Field name",
        "params": [
          {
            "default": "^[a-z][A-Za-z0-9]*$",
            "description": "Regular expression: The field names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "^[A-Z][A-Za-z0-9]*$",
            "description": "Regular expression for constants: The object field (constant) names must match this regular expression.",
            "name": "objectFieldRegex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check the number of lines in a file.*\n\nFiles which are too long can be hard to read and understand.",
        "key": "org.scalastyle.file.FileLengthChecker",
        "name": "File length",
        "params": [
          {
            "default": "1500",
            "description": "Maximum file length: Maximum number of lines in a file.",
            "name": "maxFileLength",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check the number of characters in a line.*\n\nLines that are too long can be hard to read and horizontal scrolling is annoying.",
        "key": "org.scalastyle.file.FileLineLengthChecker",
        "name": "File line length",
        "params": [
          {
            "default": "160",
            "description": "Maximum line length: Maximum number of characters in a line.",
            "name": "maxLineLength",
            "typ": "Integer"
          },
          {
            "default": "4",
            "description": "Tab size: Number of characters that a tab represents.",
            "name": "tabSize",
            "typ": "Integer"
          },
          {
            "default": "false",
            "description": "Ignore import statements: Ignore import statements.",
            "name": "ignoreImports",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that classes and objects do not define the finalize() method.*\n\n`finalize()` is called when the object is garbage collected, and garbage collection is not guaranteed to happen. It is therefore unwise to rely on code in `finalize()` method.",
        "key": "org.scalastyle.scalariform.NoFinalizeChecker",
        "name": "Finalize method",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that imports are grouped together, not throughout the file.*\n\nIf imports are spread throughout the file, knowing what is in scope at any one place can be difficult to work out.",
        "key": "org.scalastyle.scalariform.ImportGroupingChecker",
        "name": "Group imports",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that if statements have braces.*\n\nSome people find if clauses with braces easier to read.\n\nThe `singleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nThe `doubleLineAllowed` property allows if constructions of the type:\n\n```scala\nif (bool_expression) expression1 else expression2\n```\n\nNote: If you intend to enable only if expressions in the format below, disable the IfBraceChecker altogether.\n\n```scala\nif (bool_expression) expression1 else expression2\n```",
        "key": "org.scalastyle.scalariform.IfBraceChecker",
        "name": "If block braces",
        "params": [
          {
            "default": "true",
            "description": "Single Line Allowed: If without braces allowed if everything is on one line.",
            "name": "singleLineAllowed",
            "typ": "Boolean"
          },
          {
            "default": "false",
            "description": "Double Line Allowed: If without braces allowed if everything is on one line or two lines.",
            "name": "doubleLineAllowed",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that a class does not import certain classes.*\n\nUse of some classes can be discouraged for a project. For instance, use of `sun._` is generally discouraged because they are internal to the JDK and can be changed.",
        "key": "org.scalastyle.scalariform.IllegalImportsChecker",
        "name": "Illegal imports",
        "params": [
          {
            "default": "sun._,java.awt._",
            "description": "Illegal Imports: The comma separated list of illegal imports, wildcards allowed.",
            "name": "illegalImports",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that imports are grouped and ordered according to the style configuration.*\n\nConsistent import ordering improves code readability and reduces unrelated changes in patches.",
        "key": "org.scalastyle.scalariform.ImportOrderChecker",
        "name": "Import Order",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that there are no tabs in a file.*\n\nSome say that tabs are evil.",
        "key": "org.scalastyle.file.FileTabChecker",
        "name": "Line contains Tab",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that argument literals are named.*\n\nNameless literals make code harder to understand (consider `updateEntity(1, true)` and `updateEntity(id = 1, enabled = true)`).",
        "key": "org.scalastyle.scalariform.NamedArgumentChecker",
        "name": "Literal passed as argument without name",
        "params": [
          {
            "default": "false",
            "description": "Check string literals: If true, also checks that string literal arguments are named.",
            "name": "checkString",
            "typ": "Boolean"
          },
          {
            "default": "^set.+$",
            "description": "Ignore methods by pattern: Pattern to ignore method calls by name.",
            "name": "ignoreMethod",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that if a long literal is used, then an uppercase L is used.*\n\nA lowercase L (l) can look similar to a number 1 with some fonts.",
        "key": "org.scalastyle.scalariform.UppercaseLChecker",
        "name": "Long literal uppercase L",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a case statement pattern match is not lower case, as this can cause confusion.*\n\nA lower case pattern match clause with no other tokens is the same as `_`; this is not true for patterns which start with an upper case letter. This can cause confusion, and may not be what was intended:\n\n```scala\nval foo = \"foo\"\nval Bar = \"bar\"\n\"bar\" match { case Bar => \"we got bar\" } // result = \"we got bar\"\n\"bar\" match { case foo => \"we got foo\" } // result = \"we got foo\"\n\"bar\" match { case `foo` => \"we got foo\" } // result = MatchError\n```\n\nThis checker raises a warning with the second match. To fix it, use an identifier which starts with an upper case letter (best), use `case _` or, if you wish to refer to the value, add a type `: Any`, e.g.:\n\n```scala\nval lc = \"lc\"\n\"something\" match { case lc: Any => \"lc\" } // result = \"lc\"\n\"something\" match { case _ => \"lc\" } // result = \"lc\"\n```",
        "key": "org.scalastyle.scalariform.LowercasePatternMatchChecker",
        "name": "Lowercase pattern match",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of magic numbers.*\n\nReplacing a magic number with a named constant can make code easier to read and understand, and can avoid some subtle bugs.\n\nA simple assignment to a val is not considered to be a magic number, for example: `val foo = 4` is not a magic number, but `var foo = 4` is considered to be a magic number.",
        "key": "org.scalastyle.scalariform.MagicNumberChecker",
        "name": "Magic Number",
        "params": [
          {
            "default": "-1,0,1,2",
            "description": "Ignore: The comma separated list of numbers to ignore when used as magic numbers.",
            "name": "ignore",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check the first lines of each file matches the text.*\n\nA lot of projects require a header with a copyright notice, or they require a license in each file. This does a simple text comparison between the header and the first lines of the file. You can have multiple lines, but make sure you surround the text with a `CDATA` section. You can also specify a regular expression, as long as you set the regex parameter to `true`.",
        "key": "org.scalastyle.file.HeaderMatchesChecker",
        "name": "Match Header",
        "params": [
          {
            "default": "",
            "description": "Header: The lines to compare against.",
            "name": "header",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Header Regex: Whether to treat the header string as a regular expression.",
            "name": "regex",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Maximum number of parameters for a method.*\n\nA method which has more than a certain number of parameters can be hard to understand.",
        "key": "org.scalastyle.scalariform.ParameterNumberChecker",
        "name": "Maximum parameters",
        "params": [
          {
            "default": "8",
            "description": "Maximum Number: The maximum number of parameters.",
            "name": "maxParameters",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that method argument names match a regular expression.*\n\nThe Scala style guide recommends that method argument names conform to certain standards.",
        "key": "org.scalastyle.scalariform.MethodArgumentNamesChecker",
        "name": "Method argument name",
        "params": [
          {
            "default": "^[a-z][A-Za-z0-9]*$",
            "description": "Regular expression: The method argument names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "^$",
            "description": "Regular expression to ignore: Method argument names which match this regular expression will be ignored.",
            "name": "ignoreRegex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that methods do not exceed a maximum length.*\n\nLong methods can be hard to read and understand.",
        "key": "org.scalastyle.scalariform.MethodLengthChecker",
        "name": "Method length",
        "params": [
          {
            "default": "50",
            "description": "Maximum length: Maximum number of lines allowed for a method.",
            "name": "maxLength",
            "typ": "Integer"
          },
          {
            "default": "false",
            "description": "Ignore comments: If set to true, comment lines in method body won't be counted.",
            "name": "ignoreComments",
            "typ": "Boolean"
          },
          {
            "default": "false",
            "description": "Ignore empty lines: If set to true, empty lines in method body won't be counted.",
            "name": "ignoreEmpty",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that method names match a regular expression.*\n\nThe Scala style guide recommends that method names conform to certain standards. If the methods are overriding another method, and the overridden method cannot be changed, then use the `ignoreOverride` parameter.",
        "key": "org.scalastyle.scalariform.MethodNamesChecker",
        "name": "Method name",
        "params": [
          {
            "default": "^[a-z][A-Za-z0-9]*(_=)?$",
            "description": "Regular expression: The method names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "^$",
            "description": "Regular expression to ignore: Method names which match this regular expression will be ignored.",
            "name": "ignoreRegex",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
            "name": "ignoreOverride",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that the ScalaDoc on documentable members is well-formed.*\n\nScaladoc is generally considered a good thing. Within reason.\n\nIgnore tokens is a comma separated string that may include the following: `PatDefOrDcl` (variables), `TmplDef` (classes, traits), `TypeDefOrDcl` (type definitions), `FunDefOrDcl` (functions). Supported indentation styles are \"scaladoc\" (for ScalaDoc-style comments, with two spaces before the asterisk), \"javadoc\" (for JavaDoc-style comments, with a single space before the asterisk) or \"anydoc\" to support any style (any number of spaces before the asterisk). For backwards compatibility, if left empty, \"anydoc\" will be assumed.",
        "key": "org.scalastyle.scalariform.ScalaDocChecker",
        "name": "Missing or badly formed ScalaDoc",
        "params": [
          {
            "default": "^$",
            "description": "Regular expression: Class names matching this regular expression will be ignored.",
            "name": "ignoreRegex",
            "typ": "String"
          },
          {
            "default": "^$",
            "description": "Comma Separated String: Include the following to ignore : PatDefOrDcl (variables), TmplDef (classes, traits), TypeDefOrDcl (type definitions), FunDefOrDcl (functions).",
            "name": "ignoreTokenTypes",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Ignore override: If set to true, methods which have the override modifier are ignored.",
            "name": "ignoreOverride",
            "typ": "Boolean"
          },
          {
            "default": "anydoc",
            "description": "Force indent style: Possible values: scaladoc - 2 spaces before *, javadoc - 1 space before *.",
            "name": "indentStyle",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that a string literal does not appear multiple times.*\n\nCode duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant.",
        "key": "org.scalastyle.scalariform.MultipleStringLiteralsChecker",
        "name": "Multiple string literals",
        "params": [
          {
            "default": "1",
            "description": "Maximum occurences allowed: Maximum number of occurences allowed.",
            "name": "allowed",
            "typ": "Integer"
          },
          {
            "default": "^\"\"$",
            "description": "Ignore regular expression: Regular expression to ignore.",
            "name": "ignoreRegex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that a file ends with a newline character.*\n\nSome version control systems don't cope well with files which don't end with a newline character.",
        "key": "org.scalastyle.file.NewLineAtEofChecker",
        "name": "Newline at EOF",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a file does not end with a newline character.*\n\nBecause Mirco Dotta wanted it.",
        "key": "org.scalastyle.file.NoNewLineAtEofChecker",
        "name": "No Newline at EOF",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that classes and objects do not define mutable fields.*\n\n`var` (mutable fields) are deprecated if you're using a strict functional style.",
        "key": "org.scalastyle.scalariform.VarFieldChecker",
        "name": "No mutable fields",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that functions do not define mutable variables.*\n\n`var` (mutable local variables) are deprecated if you're using a strict functional style.",
        "key": "org.scalastyle.scalariform.VarLocalChecker",
        "name": "No mutable local variables",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that if expressions are not redundant, i.e. easily replaced by a variant of the condition.*\n\nIf expressions with boolean constants in both branches can be eliminated without affecting readability. Prefer simply `cond` to `if (cond) true else false` and `!cond` to `if (cond) false else true`.",
        "key": "org.scalastyle.scalariform.RedundantIfChecker",
        "name": "No redundant if expressions",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Ensure single space after certain token(s).*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.EnsureSingleSpaceAfterTokenChecker",
        "name": "No space after tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Ensure single space before certain token(s).*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker",
        "name": "No space before tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that throw is not used.*\n\n`throw` statements should be replaced with type-safe error constructs like `Try` and `Either`, which communicate the possibility of error in the type signature.",
        "key": "org.scalastyle.scalariform.ThrowChecker",
        "name": "No throw statements.",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that Java @Deprecated is not used, Scala @deprecated should be used instead.*\n\nYou should be using the Scala `@deprecated` instead.",
        "key": "org.scalastyle.scalariform.DeprecatedJavaChecker",
        "name": "No use of Java @Deprecated",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that Java @Override is not used.*\n\nYou should be using the Scala override keyword instead.",
        "key": "org.scalastyle.scalariform.OverrideJavaChecker",
        "name": "No use of Java @Override",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that while is not used.*\n\n`while` loops are deprecated if you're using a strict functional style.",
        "key": "org.scalastyle.scalariform.WhileChecker",
        "name": "No while loops",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*No whitespace after left bracket ''[''.*\n\nIf there is whitespace after a left bracket, this can be confusing to the reader.",
        "key": "org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker",
        "name": "No whitespace after left bracket ''[''",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*No whitespace before left bracket ''[''.*\n\nIf there is whitespace before a left bracket, this can be confusing to the reader.",
        "key": "org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker",
        "name": "No whitespace before left bracket ''[''",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*No whitespace before right bracket '']''.*\n\nIf there is whitespace before a right bracket, this can be confusing to the reader.",
        "key": "org.scalastyle.scalariform.NoWhitespaceBeforeRightBracketChecker",
        "name": "No whitespace before right bracket '']''",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Some editors are unfriendly to non ASCII characters.*\n\nScala allows unicode characters as operators and some editors misbehave when they see non-ascii character. In a project collaborated by a community of developers. This check can be helpful in such situations. \n\n```scala\n\"value\" match {\n  case \"value\" => println(\"matched\")\n  ...\n}\n```\n\nis preferred to\n\n```scala\n\"value\" match {\n  case \"value\" ⇒ println(\"matched\")\n  ...\n}\n```\n\nTo fix it, replace the (unicode operator) `⇒` with `=>`.",
        "key": "org.scalastyle.scalariform.NonASCIICharacterChecker",
        "name": "Non ASCII characters are not allowed",
        "params": [
          {
            "default": "false",
            "description": "Allow non-ASCII scripts in string literals.: White lists Unicode characters recognized by `\\p'{'Alnum'}'\\p'{'Punct'}'\\p'{'Sc'}'\\p'{'Space'}'` but not symbols like Emoji.",
            "name": "allowStringLiterals",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that null is not used.*\n\nScala discourages use of `null`, preferring `Option`.",
        "key": "org.scalastyle.scalariform.NullChecker",
        "name": "Null",
        "params": [
          {
            "default": "true",
            "description": "Allow null checks: Allow occurrences in checks like 'x == null' or 'x != null'.",
            "name": "allowNullChecks",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that a class / trait / object does not have too many methods.*\n\nIf a type declares too many methods, this can be an indication of bad design.",
        "key": "org.scalastyle.scalariform.NumberOfMethodsInTypeChecker",
        "name": "Number of methods in type",
        "params": [
          {
            "default": "30",
            "description": "Maximum methods: The maximum number of methods allowed.",
            "name": "maxMethods",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that there are not too many types declared in a file.*\n\nIf there are too many classes/objects defined in a single file, this can cause the code to be difficult to understand.",
        "key": "org.scalastyle.scalariform.NumberOfTypesChecker",
        "name": "Number of types",
        "params": [
          {
            "default": "20",
            "description": "Maximum Number: Maximum number of types to allow.",
            "name": "maxTypes",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that object names match a regular expression.*\n\nThe Scala style guide recommends that object names conform to certain standards.",
        "key": "org.scalastyle.scalariform.ObjectNamesChecker",
        "name": "Object name",
        "params": [
          {
            "default": "^[A-Z][A-Za-z]*$",
            "description": "Regular expression: The object names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that braces aren't used in case clauses.*\n\nBraces aren't required in case clauses. They should be omitted according to Scala Style Guide.",
        "key": "org.scalastyle.scalariform.CaseBraceChecker",
        "name": "Omit braces in case clauses",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that package names match a regular expression.*\n\nThe Scala style guide recommends that package names conform to certain standards.",
        "key": "org.scalastyle.scalariform.PackageNamesChecker",
        "name": "Package name",
        "params": [
          {
            "default": "^[a-z]+$",
            "description": "Regular expression: The package names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that package object names match a regular expression.*\n\nThe Scala style guide recommends that package object names conform to certain standards.",
        "key": "org.scalastyle.scalariform.PackageObjectNamesChecker",
        "name": "Package object name",
        "params": [
          {
            "default": "^[a-z][A-Za-z]*$",
            "description": "Regular expression: The package object names must match this regular expression.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that pattern match arrows align.*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.PatternMatchAlignChecker",
        "name": "Pattern match align",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that a method has an explicit return type, it is not inferred.*\n\nA public method declared on a type is effectively an API declaration. Explicitly declaring a return type means that other code which depends on that type won't break unexpectedly.",
        "key": "org.scalastyle.scalariform.PublicMethodsHaveTypeChecker",
        "name": "Public method must have type",
        "params": [
          {
            "default": "false",
            "description": "Ignore overridden methods: If true, public methods which override are ignored.",
            "name": "ignoreOverride",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*If a class/trait has no members, the braces are unnecessary.*\n\nIf a `class` / `trait` has no members, then braces are unnecessary, and can be removed.",
        "key": "org.scalastyle.scalariform.EmptyClassChecker",
        "name": "Redundant braces in class definition",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that a regular expression cannot be matched, if found reports this.*\n\nSome checks can be carried out with a regular expression.",
        "key": "org.scalastyle.file.RegexChecker",
        "name": "Regular expression",
        "params": [
          {
            "default": "",
            "description": "Regular expression: Standard Scala regular expression syntax including multiline.",
            "name": "regex",
            "typ": "String"
          },
          {
            "default": "false",
            "description": "Line: Boolean whether to process line by line.",
            "name": "line",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that a regular expression cannot be matched in a token, if found reports this.*\n\nSome checks can be carried by just the presence of a particular token.",
        "key": "org.scalastyle.scalariform.TokenChecker",
        "name": "Regular expression in a token",
        "params": [
          {
            "default": "^$",
            "description": "Regular expression: Standard Scala regular expression syntax.",
            "name": "regex",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that return is not used.*\n\nUse of `return` is not usually necessary in Scala. In fact, use of return can discourage a functional style of programming.",
        "key": "org.scalastyle.scalariform.ReturnChecker",
        "name": "Return",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Boolean expression can be simplified.*\n\nA boolean expression which can be simplified can make code easier to read.",
        "key": "org.scalastyle.scalariform.SimplifyBooleanExpressionChecker",
        "name": "Simplify Boolean expression",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that the plus sign is followed by a space.*\n\nAn expression with spaces around `+` can be easier to read.",
        "key": "org.scalastyle.scalariform.SpacesAfterPlusChecker",
        "name": "Space after plus",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks a space after the start of the comment.*\n\nTo bring consistency with how comments should be formatted, leave a space right after the beginning of the comment.\n\n```scala\npackage foobar\n\nobject Foobar {\n  /**WRONG\n    *\n    */\n  /** Correct\n    *\n    */\n  val d = 2 /*Wrong*/ //Wrong\n  /**\n    * Correct\n    */\n  val e = 3 /** Correct*/ // Correct\n}\n```",
        "key": "org.scalastyle.scalariform.SpaceAfterCommentStartChecker",
        "name": "Space after the start of the comment",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Disallow space after certain token(s).*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.DisallowSpaceAfterTokenChecker",
        "name": "Space after tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that the plus sign is preceded by a space.*\n\nAn expression with spaces around `+` can be easier to read.",
        "key": "org.scalastyle.scalariform.SpacesBeforePlusChecker",
        "name": "Space before plus",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Disallow space before certain token(s).*\n\nCorrect formatting can help readability.",
        "key": "org.scalastyle.scalariform.DisallowSpaceBeforeTokenChecker",
        "name": "Space before tokens",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that structural types are not used.*\n\nStructural types in Scala can use reflection - this can have unexpected performance consequences. Warning: This check can also wrongly pick up type lamdbas and other such constructs. This checker should be used with care. You always have the alternative of the scalac checking for structural types.",
        "key": "org.scalastyle.scalariform.StructuralTypeChecker",
        "name": "Structural type",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check for use of TODO/FIXME single line comments.*\n\nSome projects may consider `TODO` or `FIXME` comments in a code bad style. They would rather you fix the problem.",
        "key": "org.scalastyle.scalariform.TodoCommentChecker",
        "name": "TODO/FIXME comment",
        "params": [
          {
            "default": "TODO|FIXME",
            "description": "Word list: Alternative list of words to look for, separated by |.",
            "name": "words",
            "typ": "String"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that the code does not have ??? operators.*\n\nThe `???` operator denotes that an implementation is missing. This rule helps to avoid potential runtime errors because of not implemented code.",
        "key": "org.scalastyle.scalariform.NotImplementedErrorUsage",
        "name": "Usage of ??? operator",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Use a : Unit = for procedure declarations.*\n\nA procedure style declaration can cause confusion - the developer may have simply forgotten to add a `=`, and now their method returns `Unit` rather than the inferred type:\n\n```scala\ndef foo() { println(\"hello\"); 5 }\n```\nThis checker raises a warning with the first line. To fix it, use an explicit return type, or add a `=` before the body.\n\n```scala\ndef foo() = { println(\"hello\"); 5 }\n```",
        "key": "org.scalastyle.scalariform.ProcedureDeclarationChecker",
        "name": "Use : Unit = for procedures",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that braces are used in for comprehensions.*\n\nUsage of braces (rather than parentheses) within a `for` comprehension mean that you don't have to specify a semi-colon at the end of every line:\n\n```scala\nfor { // braces\n  t <- List(1,2,3)\n  if (t % 2 == 0)\n} yield t\n```\n\nis preferred to\n\n```scala\nfor ( // parentheses\n  t <- List(1,2,3);\n  if (t % 2 == 0)\n) yield t\n```\n\nTo fix it, replace the `()` with `{}`. And then remove the `;` at the end of the lines.\n\nThe `singleLineAllowed` property allows for constructions of the type:\n\n```scala\nfor (i <- List(1,2,3)) yield i\n```",
        "key": "org.scalastyle.scalariform.ForBraceChecker",
        "name": "Use braces in for comprehensions",
        "params": [
          {
            "default": "false",
            "description": "Allow parentheses for single-line for: For with parentheses allowed if everything is on one line.",
            "name": "singleLineAllowed",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that lines are indented by a multiple of the tab size.*\n\nCode that is not indented consistently can be hard to read.",
        "key": "org.scalastyle.file.IndentationChecker",
        "name": "Use correct indentation",
        "params": [
          {
            "default": "2",
            "description": "Tab size: Number of characters that a tab represents.",
            "name": "tabSize",
            "typ": "Integer"
          },
          {
            "default": "2",
            "description": "Multi-line method parameter spacing: Level of indentation of multi-line method parameters relative to the indentation of the first line of the method.",
            "name": "methodParamIndentSize",
            "typ": "Integer"
          },
          {
            "default": "4",
            "description": "Multi-line class parameter spacing: Level of indentation of multi-line primary constructor parameters of a class. Relative to the indentation of the first line of class declaration.",
            "name": "classParamIndentSize",
            "typ": "Integer"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Checks that parentheses are used in for loops.*\n\nFor-comprehensions which lack a `yield` clause is actually a loop rather than a functional comprehension and it is usually more readable to string the generators together between parentheses rather than using the syntactically-confusing `} {` construct:\n\n```scala\nfor (x <- board.rows; y <- board.files) {\n  printf(\"(%d, %d)\", x, y)\n}\n```\n\nis preferred to\n\n```scala\nfor {\n  x <- board.rows\n  y <- board.files\n} {\n  printf(\"(%d, %d)\", x, y)\n}\n```",
        "key": "org.scalastyle.scalariform.ForLoopChecker",
        "name": "Use parentheses in for loops",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks that while body have braces.*\n\nWhile cannot be used in a pure-functional manner, that's why it's recommended to never omit braces according to Scala Style Guide.",
        "key": "org.scalastyle.scalariform.WhileBraceChecker",
        "name": "While body should have braces",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Check that there is no trailing whitespace at the end of lines.*\n\nWhitespace at the end of a line can cause problems when diffing between files or between versions.",
        "key": "org.scalastyle.file.WhitespaceEndOfLineChecker",
        "name": "Whitespace at end of line",
        "params": [
          {
            "default": "false",
            "description": "Ignore lines with just whitespace: Skip a line if the entire contents are whitespace characters.",
            "name": "ignoreWhitespaceLines",
            "typ": "Boolean"
          }
        ],
        "severity": "Minor",
        "template": true
      },
      {
        "description": "*Check that XML literals are not used.*\n\nSome projects prefer not to have XML literals. They could use a templating engine instead.",
        "key": "org.scalastyle.scalariform.XmlLiteralChecker",
        "name": "XML literals",
        "params": [],
        "severity": "Minor",
        "template": false
      }
    ],
    "scapegoat": [
      {
        "description": "*Checks whether !isEmpty can be replaced with nonEmpty.*\n\n!.isEmpty can be replaced with.nonEmpty to make it easier to reason about.",
        "key": "com.sksamuel.scapegoat.inspections.collections.NegationIsEmpty",
        "name": "!isEmpty can be replaced with nonEmpty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks whether !nonEmpty can be replaced with isEmpty.*\n\n!.nonEmpty can be replaced with.isEmpty to make it easier to reason about.",
        "key": "com.sksamuel.scapegoat.inspections.collections.NegationNonEmpty",
        "name": "!nonEmpty can be replaced with isEmpty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for comparison of arrays using == which will always return false.*\n\nArray equals is not an equality check. Use a.deep == b.deep or convert to another collection type.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ArrayEquals",
        "name": "Array equals",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for arrays passed to String.format.*\n\nAn Array passed to String.format might result in an incorrect formatting.",
        "key": "com.sksamuel.scapegoat.inspections.string.ArraysInFormat",
        "name": "Array passed to String.format",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for ranges using (j to k - 1).*\n\nA range in the following format (j to k - 1) can be simplified to (j until k).",
        "key": "com.sksamuel.scapegoat.inspections.AvoidToMinusOne",
        "name": "Avoid (j to k - 1)",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of Traversable.size.*\n\n.size can be slow for some data structures, prefer .nonEmpty, which is O(1).",
        "key": "com.sksamuel.scapegoat.inspections.collections.AvoidSizeNotEqualsZero",
        "name": "Avoid Traversable.size != 0",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of Traversable.size.*\n\nTraversable.size can be slow for some data structures, prefer Traversable.isEmpty, which is O(1).",
        "key": "com.sksamuel.scapegoat.inspections.collections.AvoidSizeEqualsZero",
        "name": "Avoid Traversable.size == 0",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for symbolic method names.*\n\nScala style guide advocates against routinely using operators as method names, see http://docs.scala-lang.org/style/naming-conventions.html#symbolic-method-names.",
        "key": "com.sksamuel.scapegoat.inspections.style.AvoidOperatorOverload",
        "name": "Avoid operator overload",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of BigDecimal(double) which can be unsafe.*\n\nThe results of this constructor can be somewhat unpredictable. E.g. writing new BigDecimal(0.1) in Java creates a BigDecimal which is actually equal to 0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double.",
        "key": "com.sksamuel.scapegoat.inspections.math.BigDecimalDoubleConstructor",
        "name": "Big decimal double constructor",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of `setScale()` on a BigDecimal without setting the rounding mode can throw an exception.*\n\nWhen using `setScale()` on a BigDecimal without setting the rounding mode, this can throw an exception if rounding is required. Did you mean to call `setScale(s, RoundingMode.XYZ)`?",
        "key": "com.sksamuel.scapegoat.inspections.math.BigDecimalScaleWithoutRoundingMode",
        "name": "BigDecimal setScale() without rounding mode",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for types with upper bounds of a final type.*\n\nPointless type bound. Type parameter can only be a single value.",
        "key": "com.sksamuel.scapegoat.inspections.inference.BoundedByFinalType",
        "name": "Bounded by a final type",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for potentially broken odd checks.*\n\nCode that attempts to check for oddness using `x % 2 == 1` will fail on negative numbers. Consider using `x % 2 != 0`.",
        "key": "com.sksamuel.scapegoat.inspections.math.BrokenOddness",
        "name": "Broken odd check",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for try blocks that catch exception.*\n\nDid you intend to catch all exceptions? Consider catching a more specific exception class.",
        "key": "com.sksamuel.scapegoat.inspections.exception.CatchException",
        "name": "Catch exception",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for try blocks that catch fatal exceptions: VirtualMachineError, ThreadDeath, InterruptedException, LinkageError, ControlThrowable.*\n\nDid you intend to catch a fatal exception? Consider using scala.util.control.NonFatal instead.",
        "key": "com.sksamuel.scapegoat.inspections.exception.CatchFatal",
        "name": "Catch fatal exception",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for try blocks that catch Throwable.*\n\nDid you intend to catch all throwables? Consider catching a more specific exception class.",
        "key": "com.sksamuel.scapegoat.inspections.exception.CatchThrowable",
        "name": "Catch throwable",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for try blocks that catch null pointer exceptions.*\n\nAvoid using null at all cost and you shouldn't need to catch NullPointerExceptions. Prefer Option to indicate potentially missing values and use Try to materialize exceptions thrown by any external libraries.",
        "key": "com.sksamuel.scapegoat.inspections.exception.CatchNpe",
        "name": "Catching NPE",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Ensures class names adhere to the style guidelines.*\n\nClass names should begin with uppercase letter.",
        "key": "com.sksamuel.scapegoat.inspections.naming.ClassNames",
        "name": "Class name not recommended",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for negative access on a sequence, e.g. list.get(-1).*\n\nTrying to access Seq elements using a negative index will result in an IndexOutOfBoundsException.",
        "key": "com.sksamuel.scapegoat.inspections.collections.CollectionNegativeIndex",
        "name": "Collection index out of bounds",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for variables that are confusingly named.*\n\nE.g. an instance of a Set is confusingly referred to by a variable called/containing list, or the other way around.",
        "key": "com.sksamuel.scapegoat.inspections.collections.CollectionNamingConfusion",
        "name": "Collection naming confusion",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for collection operations that promote the collection to Any.*\n\nThe `:+` (append) operator on collections accepts any argument you give it, which means that you can end up with e.g. `Seq[Any]` if your types don't match.",
        "key": "com.sksamuel.scapegoat.inspections.collections.CollectionPromotionToAny",
        "name": "Collection promotion to Any",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for equality comparisons that cannot succeed.*\n\nIn most case comparing unrelated types cannot succeed and it's usually an indication of a bug.",
        "key": "com.sksamuel.scapegoat.inspections.equality.ComparingUnrelatedTypes",
        "name": "Comparing unrelated types",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for equality checks with itself.*\n\nComparison with self will always yield true.",
        "key": "com.sksamuel.scapegoat.inspections.equality.ComparisonWithSelf",
        "name": "Comparision with self",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for code like `a == List()` or `a == Nil`.*\n\nPrefer use of `isEmpty` instead of comparison to an empty List.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ComparisonToEmptyList",
        "name": "Comparison to empty list",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for code like `a == Set()` or `a == Set.empty`.*\n\nPrefer use of `isEmpty` instead of comparison to an empty Set.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ComparisonToEmptySet",
        "name": "Comparison to empty set",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for code where the if condition compiles to a constant.*\n\nAn if condition which gets compiled to a constant, like e.g. if (1 < 2) or if (false) doesn't add any value and should be avoided.",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.ConstantIf",
        "name": "Constant if expression",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for division by one.*\n\nDivide by one will always return the original value.",
        "key": "com.sksamuel.scapegoat.inspections.math.DivideByOne",
        "name": "Divide by one",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for code like !(!b).*\n\nDouble negation can be removed, e.g. !(!b) it equal to just b.",
        "key": "com.sksamuel.scapegoat.inspections.DoubleNegation",
        "name": "Double negation",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for duplicate import statements.*\n\nDuplicate imports should be removed.",
        "key": "com.sksamuel.scapegoat.inspections.imports.DuplicateImport",
        "name": "Duplicate import",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for duplicate key names in Map literals.*\n\nA map key is overwritten by a later entry.",
        "key": "com.sksamuel.scapegoat.inspections.collections.DuplicateMapKey",
        "name": "Duplicated map key",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for duplicate values in set literals.*\n\nA set value is overwritten by a later entry.",
        "key": "com.sksamuel.scapegoat.inspections.collections.DuplicateSetValue",
        "name": "Duplicated set value",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for empty case classes like, e.g. case class Faceman().*\n\nAn empty case class can be rewritten as a case object.",
        "key": "com.sksamuel.scapegoat.inspections.EmptyCaseClass",
        "name": "Empty case class",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Finds catch blocks that don't handle caught exceptions.*\n\nIf you use a try/catch block to deal with an exception, you should handle all of the caught exceptions and if for some reason you're throwing another exception in the result, you should include the original exception as the cause.",
        "key": "com.sksamuel.scapegoat.inspections.exception.SwallowedException",
        "name": "Empty catch block",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for empty for loops.*\n\nAn empty for loop isn't a common practice and in most cases is considered as dead code.",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyFor",
        "name": "Empty for loop",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for empty if blocks.*\n\nAn empty if block is considered as dead code.",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyIfBlock",
        "name": "Empty if expression",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Looks for interpolated strings that have no arguments.*\n\nString declared as interpolated but has no parameters can be turned into a regular string.",
        "key": "com.sksamuel.scapegoat.inspections.string.EmptyInterpolatedString",
        "name": "Empty interpolated string",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for empty method statements.*\n\nAn empty method is considered as dead code.",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyMethod",
        "name": "Empty method",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for empty synchronized blocks.*\n\nAn empty synchronized block is considered as dead code.",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptySynchronizedBlock",
        "name": "Empty synchronized block",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for empty try blocks.*\n\nAn empty try block is considered as dead code.",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyTryBlock",
        "name": "Empty try block",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for empty while blocks.*\n\nAn empty while block is considered as dead code.",
        "key": "com.sksamuel.scapegoat.inspections.empty.EmptyWhileBlock",
        "name": "Empty while block",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks if `exists()` can be simplified to `contains()`.*\n\n`exists(x => x == y)` can be replaced with `contains(y)`.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ExistsSimplifiableToContains",
        "name": "Exists simplifiable to contains",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for overridden finalizers that do not call super.*\n\nFinalizers should call `super.finalize()` to ensure superclasses are able to run their finalization logic.",
        "key": "com.sksamuel.scapegoat.inspections.unsafe.FinalizerWithoutSuper",
        "name": "Finalizer without super",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for equality checks on floating point types.*\n\nDue to minor rounding errors, it is not advisable to compare floating-point numbers using the == operator. Either use a threshold based comparison, or switch to a BigDecimal.",
        "key": "com.sksamuel.scapegoat.inspections.equality.ComparingFloatingPointTypes",
        "name": "Floating type comparison",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for invalid format strings.*\n\nAn unchecked exception will be thrown when a format string contains an illegal syntax or a format specifier that is incompatible with the given arguments.",
        "key": "com.sksamuel.scapegoat.inspections.string.IllegalFormatString",
        "name": "Illegal format string",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for code like option.size > 1.*\n\nOption.size > 1 can never be true, did you mean to use Option.nonEmpty instead?",
        "key": "com.sksamuel.scapegoat.inspections.option.ImpossibleOptionSizeCondition",
        "name": "Impossible Option.size condition",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for wrong number of arguments to String.format.*\n\nThe number of arguments passed to String.format doesn't correspond to the number of fields in the format string.",
        "key": "com.sksamuel.scapegoat.inspections.string.IncorrectNumberOfArgsToFormat",
        "name": "Incorrect number of args for format",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for exceptions that are not called *Exception and vice versa.*\n\nClass named exception does not derive from Exception / class derived from Exception is not named *Exception.",
        "key": "com.sksamuel.scapegoat.inspections.exception.IncorrectlyNamedExceptions",
        "name": "Incorrectly named exceptions",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for expressions like x % 1.*\n\nAny expression x % 1 will always return 0.",
        "key": "com.sksamuel.scapegoat.inspections.math.ModOne",
        "name": "Integer mod one",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for invalid regex literals.*\n\nInvalid regex literals can fail at compile time with a PatternSyntaxException. This could be caused by e.g. dangling meta characters, or unclosed escape characters, etc.",
        "key": "com.sksamuel.scapegoat.inspections.string.InvalidRegex",
        "name": "Invalid regex",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of Java conversions.*\n\nUse of Java conversions can lead to unusual behaviour. It is recommended to use JavaConverters.",
        "key": "com.sksamuel.scapegoat.inspections.collections.JavaConversionsUse",
        "name": "Java conversions",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for when elements are appended to a list.*\n\nList append is O(n). For large lists, consider using cons (::) or another data structure such as ListBuffer, Vector or a cats.data.Chain (which has constant prepend and append).",
        "key": "com.sksamuel.scapegoat.inspections.collections.ListAppend",
        "name": "List append is slow",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of List.size.*\n\nList.size is O(n). Consider using a different data type with O(1) size lookup such as Vector or an Array.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ListSize",
        "name": "List.size is O(n)",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for sealed traits without any classes extending it.*\n\nA sealed trait that is not extended is considered dead code.",
        "key": "com.sksamuel.scapegoat.inspections.LonelySealedTrait",
        "name": "Lonely sealed trait",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for strings that look like they should be interpolated.*\n\nDid you forget to prefix this string with an s, f or raw to interpolate it?",
        "key": "com.sksamuel.scapegoat.inspections.string.LooksLikeInterpolatedString",
        "name": "Looks like interpolated String",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Warns when you could use a partial function directly instead of a match block.*\n\nA map match can be replaced with a partial function for greater readability.",
        "key": "com.sksamuel.scapegoat.inspections.matching.PartialFunctionInsteadOfMatch",
        "name": "Match instead of a partial function",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for methods that have over 10 parameters.*\n\nMethods having a large number of parameters are more difficult to reason about, consider refactoring this code.",
        "key": "com.sksamuel.scapegoat.inspections.MaxParameters",
        "name": "Max parameters",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Warns on method names that don't adhere to the Scala style guidelines.*\n\nMethods should be in camelCase style with the first letter lower-case. See http://docs.scala-lang.org/style/naming-conventions.html#methods.",
        "key": "com.sksamuel.scapegoat.inspections.naming.MethodNames",
        "name": "Method name not recommended",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for functions that are defined or inferred to return Any.*\n\nMethod returns Any. Consider using a more specialized type.",
        "key": "com.sksamuel.scapegoat.inspections.inference.MethodReturningAny",
        "name": "Method returning Any",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for case classes without a final modifier.*\n\nUsing case classes without final modifier can lead to surprising breakage.",
        "key": "com.sksamuel.scapegoat.inspections.FinalModifierOnCaseClass",
        "name": "Missing final modifier on case class",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for x == Double.NaN which will always fail.*\n\nNaN comparison will always fail. Use value.isNan instead.",
        "key": "com.sksamuel.scapegoat.inspections.math.NanComparison",
        "name": "Nan comparison",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for code that overrides parent method but simply calls super.*\n\nThis method is overridden yet only calls super.",
        "key": "com.sksamuel.scapegoat.inspections.NoOpOverride",
        "name": "Noop override",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of null in assignments.*\n\nUse an Option instead when the value can be empty.",
        "key": "com.sksamuel.scapegoat.inspections.nulls.NullAssignment",
        "name": "Null assignment",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of null in method invocation.*\n\nUse an Option instead when the value can be empty and pass down a None instead.",
        "key": "com.sksamuel.scapegoat.inspections.nulls.NullParameter",
        "name": "Null parameter",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Ensures object names adhere to the Scala style guidelines.*\n\nObject names should only contain alphanumeric characters.",
        "key": "com.sksamuel.scapegoat.inspections.naming.ObjectNames",
        "name": "Object name not recommended",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for methods returning Unit that are defined without empty parentheses.*\n\nMethods should be defined with empty parentheses if they have side effects. A method returning Unit must have side effects, therefore you should declare it with ().",
        "key": "com.sksamuel.scapegoat.inspections.style.ParameterlessMethodReturnsUnit",
        "name": "Parameterless methods returns unit",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Finds type bounds of the form `A <: Any` or `A >: Nothing`.*\n\nType bound resolves to `Nothing <: T <: Any`. Did you mean to put in other bounds?",
        "key": "com.sksamuel.scapegoat.inspections.inference.PointlessTypeBounds",
        "name": "Pointless type bounds",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of Map().*\n\n`Map[K,V]()` allocates an intermediate object. Consider `Map.empty` which returns a singleton instance without creating a new object.",
        "key": "com.sksamuel.scapegoat.inspections.collections.PreferMapEmpty",
        "name": "Prefer Map.empty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of Option.size.*\n\nPrefer to use Option.isDefined, Option.isEmpty or Option.nonEmpty instead of Option.size.",
        "key": "com.sksamuel.scapegoat.inspections.option.OptionSize",
        "name": "Prefer Option.isDefined instead of Option.size",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for use of Seq().*\n\n`Seq[T]()` allocates an intermediate object. Consider `Seq.empty` which returns a singleton instance without creating a new object.",
        "key": "com.sksamuel.scapegoat.inspections.collections.PreferSeqEmpty",
        "name": "Prefer Seq.empty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of Set().*\n\n`Set[T]()` allocates an intermediate object. Consider `Set.empty` which returns a singleton instance without creating a new object.",
        "key": "com.sksamuel.scapegoat.inspections.collections.PreferSetEmpty",
        "name": "Prefer Set.empty",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for values that have Product with Serializable as their inferred type.*\n\nIt is unlikely that Product with Serializable was your target type. This is often an indication of mixing up incompatible types.",
        "key": "com.sksamuel.scapegoat.inspections.inference.ProductWithSerializableInferred",
        "name": "Product with Serializable inferred",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for overridden finalizes that are public.*\n\nPublic finalizer should be avoided as finalizers should not be programmatically invoked.",
        "key": "com.sksamuel.scapegoat.inspections.PublicFinalizer",
        "name": "PublicFinalizer",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for redundant final modifiers on methods.*\n\nA final modifier on methods that cannot be overridden is redundant.",
        "key": "com.sksamuel.scapegoat.inspections.RedundantFinalModifierOnMethod",
        "name": "Redundant final modifier on a method",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for redundant final modifier on vars.*\n\nA final modifier on a var that cannot be overridden is redundant.",
        "key": "com.sksamuel.scapegoat.inspections.RedundantFinalModifierOnVar",
        "name": "Redundant final modifier on a var",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for empty finalizers.*\n\nAn empty finalizer, e.g. override def finalize: Unit = {} is redundant and should be removed.",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.RedundantFinalizer",
        "name": "Redundant finalizer",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for the main branch and the else branch of an if being the same.*\n\nThe if statement could be refactored if both branches are the same or start with the same.",
        "key": "com.sksamuel.scapegoat.inspections.controlflow.RepeatedIfElseBody",
        "name": "Repeated body of if main and else branch",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for case statements which have the same body.*\n\nCase body is repeated. Consider merging pattern clauses together.",
        "key": "com.sksamuel.scapegoat.inspections.matching.RepeatedCaseBody",
        "name": "Repeated case body",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for boolean expressions that can be simplified.*\n\nBoolean expressions such as x == false can be re-written as !x.",
        "key": "com.sksamuel.scapegoat.inspections.style.SimplifyBooleanExpression",
        "name": "Simplify boolean expressions",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for String.substring(0).*\n\nUse of String.substring(0) will always return the same string.",
        "key": "com.sksamuel.scapegoat.inspections.string.SubstringZero",
        "name": "String.substring(0)",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for .stripMargin calls on regex strings that contain a pipe.*\n\nStrip margin will strip | from regex - possible corrupted regex.",
        "key": "com.sksamuel.scapegoat.inspections.string.StripMarginOnRegex",
        "name": "Strip margin on regex",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for code where matching is taking place on class literals.*\n\nMatching on an companion object of a case class is probably not what you intended.",
        "key": "com.sksamuel.scapegoat.inspections.matching.SuspiciousMatchOnClassObject",
        "name": "Suspicious match on class object",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for an inefficient use of filter.sort.*\n\nFilter first and then sort the remaining collection. Swap sort.filter for filter.sort for better performance.",
        "key": "com.sksamuel.scapegoat.inspections.collections.SwapSortFilter",
        "name": "Swap sort filter",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for shadowed type parameters in methods.*\n\nShadowing type parameters is considered a bad practice and should be avoided.",
        "key": "com.sksamuel.scapegoat.inspections.TypeShadowing",
        "name": "Type shadowing",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for unnecessary toInt on instances of Int or toString on Strings, etc.*\n\nCalling e.g. toString on a String or toList on a List is completely unnecessary and it's an equivalent to identity.",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryConversion",
        "name": "Unnecessary conversion",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for code like if (expr) true else false.*\n\nIf comparison is not needed. Use the condition, e.g. instead of if (a == b) true else false, use a == b or instead of if (a == b) false else true, use !(a == b).",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryIf",
        "name": "Unnecessary if condition.",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of return keyword in blocks.*\n\nScala returns the value of the last expression in a block. Use of return here is not an idiomatic Scala.",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnnecessaryReturnUse",
        "name": "Unnecessary return",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of reverse followed by head/headOption/iterator/map.*\n\n`reverse` followed by `head`, `headOption`, `iterator`, or `map` can be replaced, respectively, with `last`, `lastOption`, `reverseIterator`, or `reverseMap`.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ReverseFunc",
        "name": "Unnecessary reverse",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for catch clauses that cannot be reached.*\n\nOne or more cases are unreachable.",
        "key": "com.sksamuel.scapegoat.inspections.exception.UnreachableCatch",
        "name": "Unreachable catch",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks `Seq.contains()` and `Option.contains()` for unrelated types.*\n\n`contains()` accepts arguments af any type, which means you might be checking if your collection contains an element of an unrelated type.",
        "key": "com.sksamuel.scapegoat.inspections.collections.UnsafeContains",
        "name": "Unsafe contains",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for String.contains(value) for invalid types.*\n\nString.contains() accepts arguments af any type, which means you might be checking if your string contains an element of an unrelated type.",
        "key": "com.sksamuel.scapegoat.inspections.string.UnsafeStringContains",
        "name": "Unsafe string contains",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for unused method parameters.*\n\nUnused constructor or method parameters should be removed.",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.UnusedMethodParameter",
        "name": "Unused parameter",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of math.pow for calculating math.cbrt.*\n\nUse math.cbrt, which is clearer and more performant than math.pow(x, 1/3).",
        "key": "com.sksamuel.scapegoat.inspections.math.UseCbrt",
        "name": "Use cbrt",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of math.exp(x) - 1 instead of math.expm1(x).*\n\nUse math.expm1(x), which is clearer and more performant than math.exp(x) - 1.",
        "key": "com.sksamuel.scapegoat.inspections.math.UseExpM1",
        "name": "Use expm1",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of math.log(x)/math.log(10) instead of math.log10(x).*\n\nUse math.log10(x), which is clearer and more performant than $math.log(x)/$math.log(10).",
        "key": "com.sksamuel.scapegoat.inspections.math.UseLog10",
        "name": "Use log10",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of math.log(x + 1) instead of math.log1p(x).*\n\nUse math.log1p(x) is clearer and more performant than $math.log(1 + x).",
        "key": "com.sksamuel.scapegoat.inspections.math.UseLog1P",
        "name": "Use log1p",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for explicit toString calls on arrays.*\n\nCalling toString on an array does not perform a deep toString.",
        "key": "com.sksamuel.scapegoat.inspections.string.ArraysToString",
        "name": "Use of Array.toString",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of .get on Left or Right projection.*\n\nMethod .get on a Left and a Right projection is deprecated since 2.13, use Either.getOrElse or Either.swap.getOrElse instead.",
        "key": "com.sksamuel.scapegoat.inspections.option.EitherGet",
        "name": "Use of Either.right or Either.left projection followed by a get",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks whether Map.get().getOrElse() can be simplified to Map.getOrElse().*\n\nMap.get(key).getOrElse(value) can be replaced with Map.getOrElse(key, value), which is more concise.",
        "key": "com.sksamuel.scapegoat.inspections.collections.MapGetAndGetOrElse",
        "name": "Use of Map.get().getOrElse instead of Map.getOrElse",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for use of Option.get.*\n\nUsing Option.get defeats the purpose of using Option in the first place. Use the following instead: Option.getOrElse, Option.fold, pattern matching or don't take the value out of the container and map over it to transform it.",
        "key": "com.sksamuel.scapegoat.inspections.option.OptionGet",
        "name": "Use of Option.get",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for use of Try.get.*\n\nUsing Try.get is unsafe because it will throw the underlying exception in case of a Failure. Use the following instead: Try.getOrElse, Try.fold, pattern matching or don't take the value out of the container and map over it to transform it.",
        "key": "com.sksamuel.scapegoat.inspections.unsafe.TryGet",
        "name": "Use of Try.get",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for indexing on a Seq which is not an IndexedSeq.*\n\nUsing an index to access elements of an IndexedSeq may cause performance problems.",
        "key": "com.sksamuel.scapegoat.inspections.collections.CollectionIndexOnNonIndexedSeq",
        "name": "Use of apply method on a non-indexed Seq",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of asInstanceOf.*\n\nUse of asInstanceOf is considered a bad practice - consider using pattern matching instead.",
        "key": "com.sksamuel.scapegoat.inspections.unsafe.AsInstanceOf",
        "name": "Use of asInstanceOf",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of isInstanceOf.*\n\nUse of isInstanceOf is considered a bad practice - consider using pattern matching instead.",
        "key": "com.sksamuel.scapegoat.inspections.unsafe.IsInstanceOf",
        "name": "Use of isInstanceOf",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of unsafe methods on Traversable.*\n\nThe following methods on Traversable are considered to be unsafe (head, tail, init, last, reduce, reduceLeft, reduceRight, max, maxBy, min, minBy).",
        "key": "com.sksamuel.scapegoat.inspections.collections.UnsafeTraversableMethods",
        "name": "Use of unsafe Traversable methods.",
        "params": [],
        "severity": "Major",
        "template": false
      },
      {
        "description": "*Checks for use of math.pow for calculating math.sqrt.*\n\nUse math.sqrt, which is clearer and more performant than $math.pow(x, 0.5).",
        "key": "com.sksamuel.scapegoat.inspections.math.UseSqrt",
        "name": "Use sqrt",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for vars that could be declared as vals.*\n\nA variable (var) that is never written to could be turned into a value (val).",
        "key": "com.sksamuel.scapegoat.inspections.unneccesary.VarCouldBeVal",
        "name": "Var could be val",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Finds closures that reference variables (var).*\n\nClosing over a var can lead to subtle bugs.",
        "key": "com.sksamuel.scapegoat.inspections.VarClosure",
        "name": "Var in closure",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for multiple uses of the variable name in nested scopes.*\n\nVariable shadowing is very useful, but can easily lead to nasty bugs in your code. Shadowed variables can be potentially confusing to other maintainers when the same name is adopted to have a new meaning in a nested scope.",
        "key": "com.sksamuel.scapegoat.inspections.VariableShadowing",
        "name": "Variable shadowing",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for code that uses a while(true) or do {...} while(true) block.*\n\nA (do) while true loop is unlikely to be meant for production.",
        "key": "com.sksamuel.scapegoat.inspections.controlflow.WhileTrue",
        "name": "While true loop",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for dividing 0 by a number.*\n\nDividing zero by any number will always return zero, e.g. 0 / x == 0.",
        "key": "com.sksamuel.scapegoat.inspections.math.ZeroNumerator",
        "name": "Zero numerator",
        "params": [],
        "severity": "Minor",
        "template": false
      },
      {
        "description": "*Checks for use of filter().head.*\n\n`filter().head` can throw an exception if the collection is empty - it can be replaced with `find() match {...}`.",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotHead",
        "name": "filter().head can throw an exception",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of filter().headOption.*\n\n`filter()` scans the entire collection, which is unnecessary if you only want to get the first element that satisfies the predicate - `filter().headOption` can be replaced with `find()` to potentially avoid scanning the entire collection.",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotHeadOption",
        "name": "filter().headOption instead of find()",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of filter().isEmpty.*\n\n`filter()` scans the entire collection, which can potentially be avoided if the element exists in the collection - `filter().isEmpty` can be replaced with `!exists()`.",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotIsEmpty",
        "name": "filter().isEmpty instead of !exists()",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks if filter().size can be simplified to count().*\n\n`filter().size` can be replaced with `count()`, which is more concise.",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterDotSize",
        "name": "filter().size() instead of count()",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks whether the expression can be rewritten using flatten.*\n\n`filter(_.isDefined).map(_.get)` can be replaced with `flatten`.",
        "key": "com.sksamuel.scapegoat.inspections.collections.FilterOptionAndGet",
        "name": "filter(_.isDefined).map(_.get) instead of flatten",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks whether `find()` can be replaced with `exists()`.*\n\n`find().isDefined` can be replaced with `exists()`, which is more concise.",
        "key": "com.sksamuel.scapegoat.inspections.collections.FindDotIsDefined",
        "name": "find().isDefined() instead of exists()",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks whether `find()` can be replaced with exists().*\n\n`find() != None` can be replaced with `exists()`, which is more concise.",
        "key": "com.sksamuel.scapegoat.inspections.collections.FindAndNotEqualsNoneReplaceWithExists",
        "name": "find(x => ) != None instead of exists(x =>)",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of reverse.tail.reverse.*\n\n`reverse.tail.reverse` can be replaced with `init`, which is more concise.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ReverseTailReverse",
        "name": "reverse.tail.reverse instead of init",
        "params": [],
        "severity": "Info",
        "template": false
      },
      {
        "description": "*Checks for use of reverse.take().reverse.*\n\n`reverse.take().reverse` can be replaced with `takeRight`, which is more concise.",
        "key": "com.sksamuel.scapegoat.inspections.collections.ReverseTakeReverse",
        "name": "reverse.take().reverse instead of takeRight",
        "params": [],
        "severity": "Info",
        "template": false
      }
    ]
  }
}